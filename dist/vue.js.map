{"version":3,"file":"vue.js","sources":["../src/scheduler.js","../src/effect.js","../src/responsive.js","../src/index.js","../src/watch.js"],"sourcesContent":["// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","import { activeEffect } from './effect'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect，直接 return\r\n    if (!activeEffect) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set() // 新增\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","import flushJob, { jobQueue } from './scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './effect'\r\nimport computed from './computed'\r\nimport { track, trigger } from './responsive'\r\nimport watch from './watch'\r\n\r\n// 原始数据\r\nconst data = { foo: 1, bar: 2 }\r\n// 对原始数据拦截(只有在拦截对象obj上面操作才会走get或者set方法，在原始数据data上面操作不会走get或者set方法)\r\nconst obj = new Proxy(data, {\r\n    // 拦截读取操作\r\n    get: function (target, key) {\r\n        // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n        track(target, key)\r\n        return target[key]\r\n    },\r\n    // 拦截设置操作\r\n    set: function (target, key, newVal) {\r\n        // 设置属性值\r\n        target[key] = newVal\r\n        // 把副作用函数从桶里取出并执行\r\n        trigger(target, key)\r\n        // 防止'set' on proxy: trap returned falsish for property报错\r\n        return true\r\n    }\r\n})\r\n\r\n// 全局变量\r\n// let temp1, temp2\r\n\r\n// // effectFn1 嵌套了 effectFn2\r\n// effect(function effectFn1() {\r\n//     console.log('effectFn1 执行')\r\n\r\n//     effect(function effectFn2() {\r\n//         console.log('effectFn2 执行')\r\n//         // 在 effectFn2 中读取 obj.bar 属性\r\n//         temp2 = obj.bar\r\n//     })\r\n//     // 在 effectFn1 中读取 obj.foo 属性\r\n//     temp1 = obj.foo\r\n// })\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n const fetch = async (params) => {\r\n    let m = 0\r\n    setTimeout(() => {\r\n        m =1\r\n    }, 1000);\r\n    return m\r\n }\r\n watch(\r\n    // getter 函数\r\n    () => obj.foo,\r\n    // 回调函数\r\n    async (newValue, oldValue, onInvalidate) => {\r\n        console.log(newValue, oldValue)\r\n        // 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期\r\n        let expired = false\r\n        // 调用 onInvalidate() 函数注册一个过期回调\r\n        onInvalidate(() => {\r\n            // 当过期时，将 expired 设置为 true\r\n            expired = true\r\n        })\r\n        // 发送网络请求\r\n        const res = await fetch('/path/to/request')\r\n        // 只有当该副作用函数的执行没有过期时，才会执行后续操作。\r\n        if (!expired) {\r\n            finalData = res\r\n        }\r\n    },\r\n    {\r\n        // 回调函数会在 watch 创建时立即执行一次\r\n        immediate: true,\r\n        // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n        // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n    }\r\n)\r\n\r\n  // 修改响应数据的值，会导致回调函数执行\r\n  obj.foo++\r\n  setTimeout(() => {\r\n    // 200ms 后做第二次修改\r\n    obj.foo++\r\n  }, 200)\r\n\r\n \r\n","import effect from './effect'\r\n\r\nfunction traverse(value, seen = new Set()) {\r\n    // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做\r\n    if (typeof value !== 'object' || value === null || seen.has(value)) return\r\n    // 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环\r\n    seen.add(value)\r\n    // 暂时不考虑数组等其他结构\r\n    // 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理\r\n    for (const k in value) {\r\n        traverse(value[k], seen)\r\n    }\r\n    return value\r\n}\r\n\r\n // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数\r\n function watch(source, cb, options = {}) {\r\n    // 定义 getter\r\n    let getter\r\n    // 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter \r\n    if (typeof source === 'function') {\r\n        getter = source\r\n    } else {\r\n        // 否则按照原来的实现调用 traverse 递归地读取\r\n        getter = () => traverse(source)\r\n    }\r\n    // 定义旧值与新值\r\n    let oldValue, newValue\r\n    // cleanup 用来存储用户注册的过期回调\r\n    let cleanup\r\n    // 定义 onInvalidate 函数\r\n    function onInvalidate(fn) {\r\n        // 将过期回调存储到 cleanup 中\r\n        cleanup = fn\r\n    }\r\n    // 提取 scheduler 调度函数为一个独立的 job 函数\r\n    const job = () => {\r\n        // 在 scheduler 中重新执行副作用函数，得到的是新值\r\n        newValue = effectFn()\r\n        // 在调用回调函数 cb 之前，先调用过期回调\r\n        if (cleanup) {\r\n            cleanup()\r\n        }\r\n        // 将旧值和新值作为回调函数的参数, onInvalidate 作为回调函数的第三个参数，以便用户使用\r\n        cb(newValue, oldValue, onInvalidate)\r\n        // 更新旧值，不然下一次会得到错误的旧值\r\n        oldValue = newValue\r\n    }\r\n\r\n    // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到effectFn 中以便后续手动调用\r\n    const effectFn = effect(\r\n        // 执行 getter\r\n        () => getter(),\r\n        {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                // 在调度函数中判断 flush 是否为 'post'，如果是，将其放到微任务队列中执行\r\n                if (options.flush === 'post') {\r\n                    const p = Promise.resolve()\r\n                    p.then(job)\r\n                } else {\r\n                    job()\r\n                }\r\n            }\r\n        }\r\n    )\r\n    if (options.immediate) { \r\n        // 当 immediate 为 true 时立即执行 job，从而触发回调执行\r\n        job()\r\n    } else {\r\n        // 手动调用副作用函数，拿到的值就是旧值\r\n        oldValue = effectFn()\r\n    }\r\n }\r\n\r\n export default watch"],"names":["Promise","resolve","activeEffect","effectStack","effect","fn","effectFn","cleanup","i","deps","length","push","res","pop","options","arguments","undefined","lazy","bucket","WeakMap","obj","Proxy","foo","bar","get","target","key","depsMap","set","Map","Set","add","newVal","effectsToRun","effects","forEach","scheduler","fetch","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","params","m","wrap","_context","prev","next","setTimeout","abrupt","stop","_x","apply","this","watch","source","cb","oldValue","newValue","onInvalidate","job","getter","traverse","value","seen","_typeof","has","k","flush","then","immediate","_ref2","_callee2","expired","_context2","console","log","sent","finalData","_x2","_x3","_x4"],"mappings":"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"}