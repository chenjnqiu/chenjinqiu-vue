{"version":3,"file":"vue.esm.js","sources":["../src/observer/scheduler.js","../src/observer/effect.js","../src/util.js","../src/observer/reactive.js","../src/observer/responsive.js","../src/observer/ref.js","../src/instance/renderer.js","../src/index.js"],"sourcesContent":["// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","const toString = Object.prototype.toString\r\n\r\nexport const toTypeString = (value) => toString.call(value)\r\n\r\n// 判断map类型\r\nexport const isMap = (val) => toTypeString(val) === '[object Map]'\r\n// 判断set类型\r\nexport const isSet = (val) => toTypeString(val) === '[object Set]'","import { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './responsive'\r\nimport { isMap, isSet } from '../util'\r\n\r\nconst TriggerType = { \r\n    SET: 'SET',\r\n    ADD: 'ADD'\r\n }\r\n // 定义一个 Map 实例，存储原始对象到代理对象的映射\r\nconst reactiveMap = new Map()\r\n\r\nconst arrayInstrumentations = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\r\n        let res = originMethod.apply(this, args)\r\n        if (res === false || res === -1) {\r\n            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值\r\n            res = originMethod.apply(this.raw, args)\r\n        }\r\n        // 返回最终结果\r\n        return res\r\n    }\r\n})\r\n\r\n // 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪\r\n export let shouldTrack = true\r\n  // 重写数组的 push、pop、shift、unshift 以及 splice 方法\r\n ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {\r\n    // 取得原始 push 方法\r\n    const originMethod = Array.prototype[method]\r\n    // 重写\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // 在调用原始方法之前，禁止追踪\r\n        shouldTrack = false\r\n        // push 方法的默认行为\r\n        let res = originMethod.apply(this, args)\r\n        // 在调用原始方法之后，恢复原来的行为，即允许追踪\r\n        shouldTrack = true\r\n        return res\r\n    }\r\n })\r\n\r\n // 抽离为独立的函数，便于复用\r\n function iterationMethod() {\r\n    const target = this.raw\r\n    const itr = target[Symbol.iterator]()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val): val\r\n    track(target, ITERATE_KEY)\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                value:  value ? [wrap(value[0]), wrap(value[1])] : value,\r\n                done,\r\n            }\r\n        }\r\n    }\r\n }\r\n\r\n function valuesIterationMethod() {\r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 通过 target.values 获取原始迭代器方法\r\n    const itr = target.values()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    track(target, ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n function keysIterationMethod() { \r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 获取原始迭代器方法\r\n    const itr = target.keys()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系\r\n    track(target, MAP_KEY_ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n // 定义一个对象，将自定义的 add 方法定义到该对象下\r\n const mutableInstrumentations = {\r\n    add(key) {\r\n        // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象\r\n        const target = this.raw\r\n        // 先判断值是否已经存在\r\n        const hadKey = target.has(key)\r\n        // 通过原始数据对象执行 add 方法添加具体的值，注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的\r\n        const res = target.add(key) \r\n        // 调用 trigger 函数触发响应，并指定操作类型为 ADD\r\n        if(!hadKey) {\r\n            trigger(target, key, 'ADD')\r\n        }\r\n        // 返回操作结果\r\n        return res\r\n    },\r\n    delete(key) {\r\n        const target = this.raw\r\n        const hadKey = target.has(key)\r\n        const res = target.delete(key)\r\n        // 当要删除的元素确实存在时，才触发响应\r\n        if (hadKey) {\r\n            trigger(target, key, 'DELETE')\r\n        }\r\n        return res\r\n    },\r\n    get(key) {\r\n        // 获取原始对象\r\n        const target = this.raw\r\n        // 判断读取的 key 是否存在\r\n        const had = target.has(key)\r\n        // 追踪依赖，建立响应联系\r\n        track(target, key)\r\n        // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，则要返回使用 reactive 包装后的响应式数据\r\n        if (had) {\r\n            const res = target.get(key)\r\n            return typeof res === 'object' ? reactive(res) : res\r\n        }\r\n    },\r\n    set(key, value) {\r\n        const target = this.raw\r\n        const had = target.has(key)\r\n        // 获取旧值\r\n        const oldValue = target.get(key)\r\n        // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value\r\n        const rawValue = value.raw || value\r\n        // 设置新值\r\n        target.set(key, rawValue)\r\n        // 如果不存在，则说明是 ADD 类型的操作，意味着新增\r\n        if (!had) {\r\n            trigger(target, key, 'ADD')\r\n        } else if  (oldValue !== value || (oldValue === oldValue && value === value)) {\r\n            // 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改\r\n            trigger(target, key, 'SET')\r\n        }\r\n    },\r\n    forEach(callback, thisArg) {\r\n        // wrap 函数用来把可代理的值转换为响应式数据\r\n        const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n        // 取得原始数据对象\r\n        const target = this.raw\r\n        // 与 ITERATE_KEY 建立响应联系\r\n        track(target, ITERATE_KEY)\r\n        // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\r\n        target.forEach((v, k) => {\r\n            // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应\r\n           callback.call(thisArg, wrap(v), wrap(k), this)\r\n        })\r\n    },\r\n    // 共用 iterationMethod 方法\r\n    [Symbol.iterator]: iterationMethod,\r\n    entries: iterationMethod,\r\n    values: valuesIterationMethod,\r\n    keys: keysIterationMethod,\r\n }\r\n\r\n // 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应, 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读\r\nfunction createReactive(obj, isShallow = false, isReadonly = false) {\r\n    return new Proxy(obj, {\r\n        // 拦截读取操作，接收第三个参数 receiver\r\n        get: function (target, key, receiver) {\r\n            // 代理对象可以通过 raw 属性访问原始数据\r\n            if (key === 'raw') {\r\n                return target\r\n            }\r\n            if (key === 'size') {\r\n                // 调用 track 函数建立响应联系\r\n                track(target, ITERATE_KEY) \r\n                return Reflect.get(target, key, target)\r\n            }\r\n\r\n            if(isMap(target) || isSet(target)) {\r\n                // 返回定义在 mutableInstrumentations 对象下的方法\r\n                return mutableInstrumentations[key]\r\n            }\r\n\r\n\r\n            // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上,那么返回定义在 arrayInstrumentations 上的值\r\n            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) { \r\n                return Reflect.get(arrayInstrumentations, key, receiver)\r\n            }\r\n\r\n            // 非只读的时候才需要建立响应联系, 如果 key 的类型是 symbol，则不进行追踪\r\n            if (!isReadonly && typeof key !== 'symbol') {\r\n                // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n                track(target, key)\r\n            }\r\n            // 得到原始值结果\r\n            const res = Reflect.get(target, key, receiver)\r\n            // 如果是浅响应，则直接返回原始值\r\n            if (isShallow) {\r\n                return res\r\n            }\r\n            if (typeof res === 'object' && res !== null) {\r\n                // 调用 reactive 将结果包装成响应式数据并返回, 如果数据为只读，则调用 readonly 对值进行包装\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res\r\n        },\r\n        has: function (target, key) { \r\n            // 通过 has 拦截函数实现对 in 操作符的代理\r\n            track(target, key)\r\n            return Reflect.has(target, key)\r\n        },\r\n        ownKeys: function (target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联, 不存在得属性设置新属性值时促发\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        // 拦截设置操作\r\n        set: function (target, key, newVal, receiver) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 先获取旧值\r\n            const oldVal = target[key]\r\n\r\n            // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性\r\n            const type = Array.isArray(target)\r\n            // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度,如果是，则视作 SET 操作，否则是 ADD 操作\r\n            ? Number(key) < target.length ? 'SET' : 'ADD'\r\n            : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\r\n\r\n            // 设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)\r\n            // target === receiver.raw 说明 receiver 就是 target 的代理对象\r\n            if (target === receiver.raw) { \r\n                // 比较新值与旧值，只要当不全等，并且不都是 NaN 的时候才触发响应\r\n                if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) { \r\n                    // 把副作用函数从桶里取出并执行\r\n                    trigger(target, key, type, newVal)\r\n                } \r\n            }\r\n            // 防止'set' on proxy: trap returned falsish for property报错\r\n            return res\r\n        },\r\n        deleteProperty: function(target, key) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 检查被操作的属性是否是对象自己的属性\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target, key)\r\n            // 使用 Reflect.deleteProperty 完成属性的删除\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) { \r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        },\r\n    })\r\n}\r\n\r\nexport function reactive(obj) {\r\n    const existionProxy = reactiveMap.get(obj)\r\n    if (existionProxy) return existionProxy\r\n    // 否则，创建新的代理对象\r\n    const proxy = createReactive(obj)\r\n    // 存储到 Map 中，从而避免重复创建\r\n    reactiveMap.set(obj, proxy)\r\n    return proxy\r\n}\r\n\r\n// 浅只读\r\nexport function shallowReactive(obj) { \r\n    return createReactive(obj, true /* shallow */, true)\r\n}\r\n\r\nexport function readonly(obj) { \r\n    return createReactive(obj, false, true /* 只读 */)\r\n}","import { activeEffect } from './effect'\r\nimport { shouldTrack } from './reactive'\r\nimport { isMap, isSet } from '../util'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 设置对象不存在得属性时\r\nexport const ITERATE_KEY = Symbol()\r\n\r\n// 设置map得key相关得\r\nexport const MAP_KEY_ITERATE_KEY = Symbol()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect或者当禁止追踪时，直接 return \r\n    if (!activeEffect || !shouldTrack) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key, type, newVal) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    // 取得与 key 相关联的副作用函数\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    // 将与 key 相关联的副作用函数添加到 effectsToRun\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    // 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length属性相关联的副作用函数\r\n    if (type === 'ADD' && Array.isArray(target)) { \r\n        // 取出与 length 相关联的副作用函数\r\n        const lengthEffects = depsMap.get('length')\r\n        // 将这些副作用函数添加到 effectsToRun 中，待执行\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    // 对于索引大于或等于新的 length 值的元素， 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行\r\n    if (Array.isArray(target) && key === 'length') { \r\n        depsMap.forEach((effects, key) => {\r\n            if (key >= newVal) {\r\n                effects.forEach(effectFn => {\r\n                    if (effectFn !== activeEffect) {\r\n                        effectsToRun.add(effectFn)\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行\r\n    if (type === 'ADD' || \r\n        type === 'DELETE' ||\r\n        // 如果操作类型是 SET，并且目标对象是 Map 类型的数据，也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行\r\n        (type === 'SET' && isMap(target))\r\n    ) {\r\n        // 取得与 ITERATE_KEY 相关联的副作用函数\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n\r\n        // keys相关\r\n        const iterateEffectKeys = depsMap.get(MAP_KEY_ITERATE_KEY)\r\n        // 将与 MAP_KEY_ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffectKeys && iterateEffectKeys.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","import { reactive } from './reactive'\r\n// 封装一个 ref 函数\r\nexport function ref(val) {\r\n    // 在 ref 函数内部创建包裹对象\r\n    const wrapper = {\r\n        value: val,\r\n    }\r\n    // 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属性 __v_isRef，并且值为 true\r\n    Object.defineProperty(wrapper, '__v_isRef', {\r\n        value: true,\r\n    })\r\n    // 将包裹对象变成响应式数据\r\n    return reactive(wrapper)\r\n}\r\n\r\n// 封装一个toRef函数,防止展开符导致响应丢失问题\r\nexport function toRef(obj, key) {\r\n    const wrapper = {\r\n        get value() {\r\n            return obj[key]\r\n        }\r\n    }\r\n     // 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属性 __v_isRef，并且值为 true\r\n     Object.defineProperty(wrapper, '__v_isRef', {\r\n        value: true,\r\n    })\r\n    return wrapper\r\n}\r\n\r\n// 封装toRefs,防止展开符导致响应丢失问题\r\nexport function toRefs(obj) {\r\n    const ret = {}\r\n    // 使用 for...in 循环遍历对象\r\n    for (const key in obj) {\r\n        // 逐个调用 toRef 完成转换\r\n        ret[key] = toRef(obj, key)\r\n    }\r\n    return ret\r\n}\r\n\r\n// 将toRef转换后得value值，用proxy取回来, 组件中的 setup 函数所返回的数据会传递给 proxyRefs 函数进行处理\r\nexport function proxyRefs(target) {\r\n    return new Proxy(target, {\r\n        get(target, key, receiver){\r\n            const value = Reflect.get(target, key, receiver)\r\n            // 自动脱 ref 实现：如果读取的值是 ref，则返回它的 value 属性值\r\n            return value.__v_isRef ? value.value : value\r\n        },\r\n        set(target, key, newValue, receiver) {\r\n            // 通过 target 读取真实值\r\n            const value = target[key]\r\n            // 如果值是 Ref，则设置其对应的 value 属性值\r\n            if (value.__v_isRef) {\r\n                value.value = newValue\r\n                return true\r\n            }\r\n            return Reflect.set(target, key, newValue, receiver)\r\n        }\r\n    })\r\n}","\r\nfunction mountElement(vnode, container) {\r\n    // 创建 DOM 元素\r\n    const el = document.createElement(vnode.type)\r\n    // 处理子节点，如果子节点是字符串，代表元素具有文本节点\r\n    if (typeof vnode.children === 'string') {\r\n        // 因此只需要设置元素的 textContent 属性即可\r\n        el.textContent = vnode.children\r\n    }\r\n    // 将元素添加到容器中\r\n    container.appendChild(el)\r\n}\r\n\r\nfunction createRenderer() {\r\n    // n1：旧 vnode, n2：新 vnode, container：容器\r\n    function patch(n1, n2, container) {\r\n        // 如果 n1 不存在，意味着挂载，则调用 mountElement 函数完成挂载\r\n        if (!n1) {\r\n            mountElement(n2, container)\r\n        } else {\r\n            // n1 存在，意味着打补丁\r\n        }\r\n    }\r\n    function render(vnode, container) {\r\n        if (vnode) {\r\n            // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数，进行打补\r\n            patch(container._vnode, vnode, container)\r\n        } else {\r\n            if (container._vnode) {\r\n                // 旧 vnode 存在，且新 vnode 不存在，说明是卸载（unmount）操作,只需要将 container 内的 DOM 清空即可\r\n                container.innerHTML = ''\r\n            }\r\n        }\r\n        // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\r\n        container._vnode = vnode\r\n    }\r\n    function hydrate(vnode, container) {\r\n\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n    }\r\n}\r\n\r\nexport default createRenderer","import flushJob, { jobQueue } from './observer/scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './observer/effect'\r\nimport computed from './observer/computed'\r\nimport { track, trigger, ITERATE_KEY } from './observer/responsive'\r\nimport watch from './observer/watch'\r\nimport { reactive, shallowReactive, readonly } from './observer/reactive'\r\nimport { ref, toRefs, toRef, proxyRefs } from './observer/ref'\r\nimport createRenderer from './instance/renderer'\r\n\r\nconst renderer = createRenderer()\r\n\r\n// const obj = {}\r\n// const proto = { bar: 1 }\r\n// const child = reactive(obj)\r\n// const parent = reactive(proto)\r\n//  // 使用 parent 作为 child 的原型\r\n//  Object.setPrototypeOf(child, parent)\r\n//  effect(() => {\r\n//     console.log(child.bar)\r\n//  })\r\n//   // 修改 child.bar 的值\r\n//   child.bar = 2 // 会导致副作用函数重新执行两次\r\n\r\n// 深响应\r\n// const obj = reactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // 修改 obj.foo.bar 的值，并不能触发响应\r\n// obj.foo.bar = 2\r\n\r\n// 浅响应\r\n// const obj = shallowReactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // obj.foo 是响应的，可以触发副作用函数重新执行\r\n// obj.foo = { bar: 2 }\r\n// // obj.foo.bar 不是响应的，不能触发副作用函数重新执行\r\n// obj.foo.bar = 3\r\n\r\n// 只读\r\n// const obj = readonly({ foo: 1 })\r\n// effect(() => {\r\n//     obj.foo // 可以读取值，但是不需要在副作用函数与数据之间建立响应联系\r\n// })\r\n// // 尝试修改数据，会得到警告\r\n// obj.foo = 2\r\n\r\n// // set\r\n// const p = reactive(new Set([1, 2, 3]))\r\n// // 第一个副作用函数\r\n// effect(() => {\r\n//     console.log(p.size)\r\n// })\r\n// p.add(4)\r\n// p.delete(1)\r\n\r\n// map\r\n// const p = reactive(new Map([['key', 1]]))\r\n// effect(() => {\r\n//     console.log(p.get('key'))\r\n// })\r\n// p.set('key', 2) // 触发响应\r\n\r\n// 迭代器\r\n// const p = reactive(new Map([\r\n//     ['key1', 'value1'],\r\n//     ['key2', 'value2']\r\n// ]))\r\n// effect(() => {\r\n//     for (const [key, value] of p) {\r\n//         console.log(key, value)\r\n//     }\r\n// })\r\n// p.set('key3', 'value3')\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n//  watch(\r\n//     // getter 函数\r\n//     () => obj.foo,\r\n//     // 回调函数\r\n//     async (newValue, oldValue, onInvalidate) => {\r\n//         console.log(newValue, oldValue)\r\n//     },\r\n//     {\r\n//         // 回调函数会在 watch 创建时立即执行一次\r\n//         immediate: true,\r\n//         // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n//         // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n//     }\r\n// )\r\n\r\n\r\n// 原始值\r\n//  const name = ref('vue')\r\n//  effect(() => {\r\n//     console.log(name.value)\r\n//  })\r\n//  // 修改值可以触发响应\r\n//  name.value = 'vue3'\r\n\r\n//  const obj = reactive({ foo: 1, bar: 2 })\r\n//  effect(() => {\r\n//     console.log(proxyRefs({...toRefs(obj)}))\r\n\r\n//  })\r\n//  obj.foo = 2\r\n//  obj.bar = 3 \r\n\r\n\r\nconst vnode = {\r\n    type: 'h1',\r\n    children: 'hello',\r\n}\r\nconst count = ref(1)\r\neffect(() => {\r\n    renderer.render(vnode, document.getElementById('app'))\r\n}) \r\ncount.value++"],"names":["Promise","resolve","activeEffect","effectStack","effect","fn","effectFn","cleanup","push","res","pop","length","options","arguments","undefined","deps","lazy","i","toString","Object","prototype","toTypeString","value","call","isMap","val","isSet","reactiveMap","Map","arrayInstrumentations","shouldTrack","forEach","method","originMethod","Array","_len","args","_key","apply","this","raw","iterationMethod","wrap","_typeof","reactive","target","itr","Symbol","iterator","track","ITERATE_KEY","next","_itr$next","done","valuesIterationMethod","values","_defineProperty","_itr$next2","keysIterationMethod","keys","MAP_KEY_ITERATE_KEY","_itr$next3","_len2","_key2","_mutableInstrumentati","add","key","hadKey","has","trigger","delete","_delete","get","had","set","oldValue","rawValue","callback","thisArg","_this","v","k","mutableInstrumentations","createReactive","obj","isShallow","isReadonly","Proxy","receiver","Reflect","isArray","hasOwnProperty","readonly","ownKeys","newVal","oldVal","type","console","warn","concat","Number","deleteProperty","existionProxy","proxy","bucket","WeakMap","depsMap","Set","effectsToRun","iterateEffects","effects","lengthEffects","iterateEffectKeys","scheduler","ref","wrapper","defineProperty","mountElement","vnode","container","el","document","createElement","children","textContent","appendChild","createRenderer","render","n1","n2","_vnode","innerHTML","hydrate","renderer","count","getElementById"],"mappings":"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"}