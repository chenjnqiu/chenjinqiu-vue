{"version":3,"file":"vue.esm.js","sources":["../src/scheduler.js","../src/effect.js","../src/responsive.js","../src/watch.js","../src/index.js"],"sourcesContent":["// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","import { activeEffect } from './effect'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect，直接 return\r\n    if (!activeEffect) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set() // 新增\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","import effect from './effect'\r\n\r\nfunction traverse(value, seen = new Set()) {\r\n    // 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做\r\n    if (typeof value !== 'object' || value === null || seen.has(value)) return\r\n    // 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环\r\n    seen.add(value)\r\n    // 暂时不考虑数组等其他结构\r\n    // 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理\r\n    for (const k in value) {\r\n        traverse(value[k], seen)\r\n    }\r\n    return value\r\n}\r\n\r\n // watch 函数接收两个参数，source 是响应式数据，cb 是回调函数\r\n function watch(source, cb, options = {}) {\r\n    // 定义 getter\r\n    let getter\r\n    // 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter \r\n    if (typeof source === 'function') {\r\n        getter = source\r\n    } else {\r\n        // 否则按照原来的实现调用 traverse 递归地读取\r\n        getter = () => traverse(source)\r\n    }\r\n    // 定义旧值与新值\r\n    let oldValue, newValue\r\n    // cleanup 用来存储用户注册的过期回调\r\n    let cleanup\r\n    // 定义 onInvalidate 函数\r\n    function onInvalidate(fn) {\r\n        // 将过期回调存储到 cleanup 中\r\n        cleanup = fn\r\n    }\r\n    // 提取 scheduler 调度函数为一个独立的 job 函数\r\n    const job = () => {\r\n        // 在 scheduler 中重新执行副作用函数，得到的是新值\r\n        newValue = effectFn()\r\n        // 在调用回调函数 cb 之前，先调用过期回调\r\n        if (cleanup) {\r\n            cleanup()\r\n        }\r\n        // 将旧值和新值作为回调函数的参数, onInvalidate 作为回调函数的第三个参数，以便用户使用\r\n        cb(newValue, oldValue, onInvalidate)\r\n        // 更新旧值，不然下一次会得到错误的旧值\r\n        oldValue = newValue\r\n    }\r\n\r\n    // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到effectFn 中以便后续手动调用\r\n    const effectFn = effect(\r\n        // 执行 getter\r\n        () => getter(),\r\n        {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                // 在调度函数中判断 flush 是否为 'post'，如果是，将其放到微任务队列中执行\r\n                if (options.flush === 'post') {\r\n                    const p = Promise.resolve()\r\n                    p.then(job)\r\n                } else {\r\n                    job()\r\n                }\r\n            }\r\n        }\r\n    )\r\n    if (options.immediate) { \r\n        // 当 immediate 为 true 时立即执行 job，从而触发回调执行\r\n        job()\r\n    } else {\r\n        // 手动调用副作用函数，拿到的值就是旧值\r\n        oldValue = effectFn()\r\n    }\r\n }\r\n\r\n export default watch","import flushJob, { jobQueue } from './scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './effect'\r\nimport computed from './computed'\r\nimport { track, trigger } from './responsive'\r\nimport watch from './watch'\r\n\r\n// 原始数据\r\nconst data = { foo: 1, bar: 2 }\r\n// 对原始数据拦截(只有在拦截对象obj上面操作才会走get或者set方法，在原始数据data上面操作不会走get或者set方法)\r\nconst obj = new Proxy(data, {\r\n    // 拦截读取操作\r\n    get: function (target, key) {\r\n        // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n        track(target, key)\r\n        return target[key]\r\n    },\r\n    // 拦截设置操作\r\n    set: function (target, key, newVal) {\r\n        // 设置属性值\r\n        target[key] = newVal\r\n        // 把副作用函数从桶里取出并执行\r\n        trigger(target, key)\r\n        // 防止'set' on proxy: trap returned falsish for property报错\r\n        return true\r\n    }\r\n})\r\n\r\n// 全局变量\r\n// let temp1, temp2\r\n\r\n// // effectFn1 嵌套了 effectFn2\r\n// effect(function effectFn1() {\r\n//     console.log('effectFn1 执行')\r\n\r\n//     effect(function effectFn2() {\r\n//         console.log('effectFn2 执行')\r\n//         // 在 effectFn2 中读取 obj.bar 属性\r\n//         temp2 = obj.bar\r\n//     })\r\n//     // 在 effectFn1 中读取 obj.foo 属性\r\n//     temp1 = obj.foo\r\n// })\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n const fetch = async (params) => {\r\n    let m = 0\r\n    setTimeout(() => {\r\n        m =1\r\n    }, 1000);\r\n    return m\r\n }\r\n watch(\r\n    // getter 函数\r\n    () => obj.foo,\r\n    // 回调函数\r\n    async (newValue, oldValue, onInvalidate) => {\r\n        console.log(newValue, oldValue)\r\n        // 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期\r\n        let expired = false\r\n        // 调用 onInvalidate() 函数注册一个过期回调\r\n        onInvalidate(() => {\r\n            // 当过期时，将 expired 设置为 true\r\n            expired = true\r\n        })\r\n        // 发送网络请求\r\n        const res = await fetch('/path/to/request')\r\n        // 只有当该副作用函数的执行没有过期时，才会执行后续操作。\r\n        if (!expired) {\r\n            finalData = res\r\n        }\r\n    },\r\n    {\r\n        // 回调函数会在 watch 创建时立即执行一次\r\n        immediate: true,\r\n        // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n        // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n    }\r\n)\r\n\r\n  // 修改响应数据的值，会导致回调函数执行\r\n  obj.foo++\r\n  setTimeout(() => {\r\n    // 200ms 后做第二次修改\r\n    obj.foo++\r\n  }, 200)\r\n\r\n \r\n"],"names":["Promise","resolve","activeEffect","effectStack","effect","fn","effectFn","cleanup","push","res","pop","length","options","arguments","undefined","deps","lazy","i","bucket","WeakMap","track","target","key","depsMap","get","set","Map","Set","add","trigger","effectsToRun","effects","forEach","scheduler","traverse","value","seen","_typeof","has","k","watch","source","cb","oldValue","newValue","onInvalidate","job","getter","flush","then","immediate","data","foo","bar","obj","Proxy","newVal","fetch","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","params","m","wrap","_context","prev","next","setTimeout","abrupt","stop","_x","apply","this","_ref2","_callee2","expired","_context2","console","log","sent","finalData","_x2","_x3","_x4"],"mappings":"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"}