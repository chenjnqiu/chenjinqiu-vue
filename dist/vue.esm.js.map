{"version":3,"file":"vue.esm.js","sources":["../src/observer/scheduler.js","../src/observer/effect.js","../src/util.js","../src/observer/reactive.js","../src/observer/responsive.js","../src/vdom/create-element.js","../src/instance/scheduler.js","../src/instance/renderer.js","../src/index.js"],"sourcesContent":["// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","const toString = Object.prototype.toString\r\n\r\nexport const toTypeString = (value) => toString.call(value)\r\n\r\n// 判断map类型\r\nexport const isMap = (val) => toTypeString(val) === '[object Map]'\r\n// 判断set类型\r\nexport const isSet = (val) => toTypeString(val) === '[object Set]'\r\n\r\n// 最长排序\r\nexport function lis(nums) {\r\n    const tails = [];\r\n    for (let num of nums) {\r\n      let l = 0, r = tails.length - 1;\r\n      while (l <= r) {\r\n        const mid = Math.floor((l + r) / 2);\r\n        if (tails[mid] < num) {\r\n          l = mid + 1;\r\n        } else {\r\n          r = mid - 1;\r\n        }\r\n      }\r\n      tails[l] = num;\r\n    }\r\n    return tails;\r\n  }","import { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './responsive'\r\nimport { isMap, isSet } from '../util'\r\n\r\nconst TriggerType = { \r\n    SET: 'SET',\r\n    ADD: 'ADD'\r\n }\r\n // 定义一个 Map 实例，存储原始对象到代理对象的映射\r\nconst reactiveMap = new Map()\r\n\r\nconst arrayInstrumentations = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\r\n        let res = originMethod.apply(this, args)\r\n        if (res === false || res === -1) {\r\n            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值\r\n            res = originMethod.apply(this.raw, args)\r\n        }\r\n        // 返回最终结果\r\n        return res\r\n    }\r\n})\r\n\r\n // 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪\r\n export let shouldTrack = true\r\n  // 重写数组的 push、pop、shift、unshift 以及 splice 方法\r\n ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {\r\n    // 取得原始 push 方法\r\n    const originMethod = Array.prototype[method]\r\n    // 重写\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // 在调用原始方法之前，禁止追踪\r\n        shouldTrack = false\r\n        // push 方法的默认行为\r\n        let res = originMethod.apply(this, args)\r\n        // 在调用原始方法之后，恢复原来的行为，即允许追踪\r\n        shouldTrack = true\r\n        return res\r\n    }\r\n })\r\n\r\n // 抽离为独立的函数，便于复用\r\n function iterationMethod() {\r\n    const target = this.raw\r\n    const itr = target[Symbol.iterator]()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val): val\r\n    track(target, ITERATE_KEY)\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                value:  value ? [wrap(value[0]), wrap(value[1])] : value,\r\n                done,\r\n            }\r\n        }\r\n    }\r\n }\r\n\r\n function valuesIterationMethod() {\r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 通过 target.values 获取原始迭代器方法\r\n    const itr = target.values()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    track(target, ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n function keysIterationMethod() { \r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 获取原始迭代器方法\r\n    const itr = target.keys()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系\r\n    track(target, MAP_KEY_ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n // 定义一个对象，将自定义的 add 方法定义到该对象下\r\n const mutableInstrumentations = {\r\n    add(key) {\r\n        // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象\r\n        const target = this.raw\r\n        // 先判断值是否已经存在\r\n        const hadKey = target.has(key)\r\n        // 通过原始数据对象执行 add 方法添加具体的值，注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的\r\n        const res = target.add(key) \r\n        // 调用 trigger 函数触发响应，并指定操作类型为 ADD\r\n        if(!hadKey) {\r\n            trigger(target, key, 'ADD')\r\n        }\r\n        // 返回操作结果\r\n        return res\r\n    },\r\n    delete(key) {\r\n        const target = this.raw\r\n        const hadKey = target.has(key)\r\n        const res = target.delete(key)\r\n        // 当要删除的元素确实存在时，才触发响应\r\n        if (hadKey) {\r\n            trigger(target, key, 'DELETE')\r\n        }\r\n        return res\r\n    },\r\n    get(key) {\r\n        // 获取原始对象\r\n        const target = this.raw\r\n        // 判断读取的 key 是否存在\r\n        const had = target.has(key)\r\n        // 追踪依赖，建立响应联系\r\n        track(target, key)\r\n        // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，则要返回使用 reactive 包装后的响应式数据\r\n        if (had) {\r\n            const res = target.get(key)\r\n            return typeof res === 'object' ? reactive(res) : res\r\n        }\r\n    },\r\n    set(key, value) {\r\n        const target = this.raw\r\n        const had = target.has(key)\r\n        // 获取旧值\r\n        const oldValue = target.get(key)\r\n        // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value\r\n        const rawValue = value.raw || value\r\n        // 设置新值\r\n        target.set(key, rawValue)\r\n        // 如果不存在，则说明是 ADD 类型的操作，意味着新增\r\n        if (!had) {\r\n            trigger(target, key, 'ADD')\r\n        } else if  (oldValue !== value || (oldValue === oldValue && value === value)) {\r\n            // 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改\r\n            trigger(target, key, 'SET')\r\n        }\r\n    },\r\n    forEach(callback, thisArg) {\r\n        // wrap 函数用来把可代理的值转换为响应式数据\r\n        const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n        // 取得原始数据对象\r\n        const target = this.raw\r\n        // 与 ITERATE_KEY 建立响应联系\r\n        track(target, ITERATE_KEY)\r\n        // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\r\n        target.forEach((v, k) => {\r\n            // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应\r\n           callback.call(thisArg, wrap(v), wrap(k), this)\r\n        })\r\n    },\r\n    // 共用 iterationMethod 方法\r\n    [Symbol.iterator]: iterationMethod,\r\n    entries: iterationMethod,\r\n    values: valuesIterationMethod,\r\n    keys: keysIterationMethod,\r\n }\r\n\r\n // 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应, 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读\r\nfunction createReactive(obj, isShallow = false, isReadonly = false) {\r\n    return new Proxy(obj, {\r\n        // 拦截读取操作，接收第三个参数 receiver\r\n        get: function (target, key, receiver) {\r\n            // 代理对象可以通过 raw 属性访问原始数据\r\n            if (key === 'raw') {\r\n                return target\r\n            }\r\n            if (key === 'size') {\r\n                // 调用 track 函数建立响应联系\r\n                track(target, ITERATE_KEY) \r\n                return Reflect.get(target, key, target)\r\n            }\r\n\r\n            if(isMap(target) || isSet(target)) {\r\n                // 返回定义在 mutableInstrumentations 对象下的方法\r\n                return mutableInstrumentations[key]\r\n            }\r\n\r\n\r\n            // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上,那么返回定义在 arrayInstrumentations 上的值\r\n            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) { \r\n                return Reflect.get(arrayInstrumentations, key, receiver)\r\n            }\r\n\r\n            // 非只读的时候才需要建立响应联系, 如果 key 的类型是 symbol，则不进行追踪\r\n            if (!isReadonly && typeof key !== 'symbol') {\r\n                // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n                track(target, key)\r\n            }\r\n            // 得到原始值结果\r\n            const res = Reflect.get(target, key, receiver)\r\n            // 如果是浅响应，则直接返回原始值\r\n            if (isShallow) {\r\n                return res\r\n            }\r\n            if (typeof res === 'object' && res !== null) {\r\n                // 调用 reactive 将结果包装成响应式数据并返回, 如果数据为只读，则调用 readonly 对值进行包装\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res\r\n        },\r\n        has: function (target, key) { \r\n            // 通过 has 拦截函数实现对 in 操作符的代理\r\n            track(target, key)\r\n            return Reflect.has(target, key)\r\n        },\r\n        ownKeys: function (target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联, 不存在得属性设置新属性值时促发\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        // 拦截设置操作\r\n        set: function (target, key, newVal, receiver) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 先获取旧值\r\n            const oldVal = target[key]\r\n\r\n            // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性\r\n            const type = Array.isArray(target)\r\n            // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度,如果是，则视作 SET 操作，否则是 ADD 操作\r\n            ? Number(key) < target.length ? 'SET' : 'ADD'\r\n            : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\r\n\r\n            // 设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)\r\n            // target === receiver.raw 说明 receiver 就是 target 的代理对象\r\n            if (target === receiver.raw) { \r\n                // 比较新值与旧值，只要当不全等，并且不都是 NaN 的时候才触发响应\r\n                if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) { \r\n                    // 把副作用函数从桶里取出并执行\r\n                    trigger(target, key, type, newVal)\r\n                } \r\n            }\r\n            // 防止'set' on proxy: trap returned falsish for property报错\r\n            return res\r\n        },\r\n        deleteProperty: function(target, key) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 检查被操作的属性是否是对象自己的属性\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target, key)\r\n            // 使用 Reflect.deleteProperty 完成属性的删除\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) { \r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        },\r\n    })\r\n}\r\n\r\nexport function reactive(obj) {\r\n    const existionProxy = reactiveMap.get(obj)\r\n    if (existionProxy) return existionProxy\r\n    // 否则，创建新的代理对象\r\n    const proxy = createReactive(obj)\r\n    // 存储到 Map 中，从而避免重复创建\r\n    reactiveMap.set(obj, proxy)\r\n    return proxy\r\n}\r\n\r\n// 浅只读\r\nexport function shallowReactive(obj) { \r\n    return createReactive(obj, true /* shallow */, true)\r\n}\r\n\r\nexport function readonly(obj) { \r\n    return createReactive(obj, false, true /* 只读 */)\r\n}","import { activeEffect } from './effect'\r\nimport { shouldTrack } from './reactive'\r\nimport { isMap, isSet } from '../util'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 设置对象不存在得属性时\r\nexport const ITERATE_KEY = Symbol()\r\n\r\n// 设置map得key相关得\r\nexport const MAP_KEY_ITERATE_KEY = Symbol()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect或者当禁止追踪时，直接 return \r\n    if (!activeEffect || !shouldTrack) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key, type, newVal) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    // 取得与 key 相关联的副作用函数\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    // 将与 key 相关联的副作用函数添加到 effectsToRun\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    // 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length属性相关联的副作用函数\r\n    if (type === 'ADD' && Array.isArray(target)) { \r\n        // 取出与 length 相关联的副作用函数\r\n        const lengthEffects = depsMap.get('length')\r\n        // 将这些副作用函数添加到 effectsToRun 中，待执行\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    // 对于索引大于或等于新的 length 值的元素， 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行\r\n    if (Array.isArray(target) && key === 'length') { \r\n        depsMap.forEach((effects, key) => {\r\n            if (key >= newVal) {\r\n                effects.forEach(effectFn => {\r\n                    if (effectFn !== activeEffect) {\r\n                        effectsToRun.add(effectFn)\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行\r\n    if (type === 'ADD' || \r\n        type === 'DELETE' ||\r\n        // 如果操作类型是 SET，并且目标对象是 Map 类型的数据，也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行\r\n        (type === 'SET' && isMap(target))\r\n    ) {\r\n        // 取得与 ITERATE_KEY 相关联的副作用函数\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n\r\n        // keys相关\r\n        const iterateEffectKeys = depsMap.get(MAP_KEY_ITERATE_KEY)\r\n        // 将与 MAP_KEY_ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffectKeys && iterateEffectKeys.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","// 文本节点的 type 标识\r\nexport const Text = Symbol()\r\n\r\n// 注释节点的 type 标识\r\nexport const Comment = Symbol()\r\n\r\nexport const Fragment = Symbol()\r\n\r\n// 用于创建元素\r\nexport function createElement(tag){\r\n    return document.createElement(tag)\r\n}\r\n// 用于设置元素的文本节点\r\nexport function setElementText(el, text) {\r\n    el.textContent = text\r\n}\r\n// 用于在给定的 parent 下添加指定元素\r\nexport function insert(el, parent, anchor = null) {\r\n    if(parent.type === 'root') {\r\n        parent = document.getElementById('app')\r\n    }\r\n    parent.insertBefore(el, anchor)\r\n}\r\n\r\n// 创建文本节点\r\nexport function createText(text) {\r\n    return document.createTextNode(text)\r\n}\r\n\r\n// 设置文本节点\r\nexport function setText(el, text) {\r\n    el.nodeValue = text\r\n}\r\n\r\n// 创建注释节点\r\nexport function createComment(text) {\r\n    return document.createComment(text)\r\n}\r\n\r\n// 特殊处理props\r\nfunction shouldSetAsProps(el, key, value) {\r\n    if (key === 'form' && el.tagName === 'INPUT') return false\r\n    return key in el\r\n}\r\n\r\n// 将属性设置相关操作封装到 patchProps 函数中，并作为渲染器选项传递\r\nexport function patchProps(el, key, prevValue, nextValue) {\r\n    // 匹配以 on 开头的属性，视其为事件\r\n    if (/^on/.test(key)) {\r\n        // 定义 el._vei 为一个对象，存在事件名称到事件处理函数的映射\r\n        let invokers = el._vei || (el._vei = {})\r\n        //根据事件名称获取 invoker\r\n        let invoker = invokers[key]\r\n        // 根据属性名称得到对应的事件名称，例如 onClick ---> click\r\n        const name = key.slice(2).toLowerCase()\r\n        if (nextValue) {\r\n            if (!invoker) {\r\n                // 如果没有 invoker，则将一个伪造的 invoker 缓存到 el._vei 中vei 是 vue event invoker 的首字母缩写\r\n                invoker = el._vei[key] = (e) => {\r\n                    // e.timeStamp 是事件发生的时间, 如果事件发生的时间早于事件处理函数绑定的时间，则不执行事件处理函数\r\n                    if (e.timeStamp < invoker.attached) return\r\n                    // 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数\r\n                    if (Array.isArray(invoker.value)) {\r\n                        invoker.value.forEach(fn => fn(e))\r\n                    } else {\r\n                        // 否则直接作为函数调用\r\n                        invoker.value(e)\r\n                    }\r\n                }\r\n                // 将真正的事件处理函数赋值给 invoker.val\r\n                invoker.value = nextValue\r\n                // 添加 invoker.attached 属性，存储事件处理函数被绑定的时间\r\n                invoker.attached = performance.now()\r\n                // 绑定 invoker 作为事件处理函数\r\n                el.addEventListener(name, invoker)\r\n            } else {\r\n                // 如果 invoker 存在，意味着更新，并且只需要更新 invoker.value的值即可\r\n                invoker.value = nextValue\r\n            }\r\n        } else if(invoker) {\r\n            // 新的事件绑定函数不存在，且之前绑定的 invoker 存在，则移除绑定\r\n            el.removeEventListener(name, invoker)\r\n        }\r\n        // 绑定事件，nextValue 为事件处理函数\r\n        el.addEventListener(name, nextValue)\r\n    }\r\n    else if (key === 'class') { // 对 class 进行特殊处理\r\n        el.className = nextValue || ''\r\n    } else if (shouldSetAsProps(el, key, nextValue)) {  // 使用 shouldSetAsProps 函数判断是否应该作为 DOM Properties设置\r\n        // 获取该 DOM Properties 的类型\r\n        const type = typeof el[key]\r\n        // 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true\r\n        if (type === 'boolean' && nextValue === '') {\r\n            el[key] = true\r\n        } else {\r\n            el[key] = nextValue\r\n        }\r\n    } else {\r\n        // 如果要设置的属性没有对应的 DOM Properties，则使用setAttribute 函数设置属性\r\n        el.setAttribute(key, nextValue)\r\n    }\r\n}","\r\n// 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重\r\nconst queue = new Set()\r\n// 一个标志，代表是否正在刷新任务队列\r\nlet isFlushing = false\r\n// 创建一个立即 resolve 的 Promise 实例\r\n const p = Promise.resolve()\r\n// 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列\r\nfunction queueJob(job) {\r\n    // 将 job 添加到任务队列 queue 中\r\n    queue.add(job)\r\n    // 如果还没有开始刷新队列，则刷新之\r\n    if (!isFlushing) {\r\n        // 将该标志设置为 true 以避免重复刷新\r\n        isFlushing = true\r\n        // 在微任务中刷新缓冲队列\r\n        p.then(() => {\r\n            try {\r\n                // 执行任务队列中的任务\r\n                queue.forEach(job => job())\r\n            } finally {\r\n                // 重置状态\r\n                isFlushing = false\r\n                queue.clear = 0\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport default queueJob","import { \r\n    Text, \r\n    Comment,\r\n    Fragment,\r\n} from '../vdom/create-element'\r\nimport { reactive, shallowReactive } from '../observer/reactive'\r\nimport { lis } from '../util'\r\nimport queueJob from './scheduler'\r\nimport effect from '../observer/effect'\r\n\r\n// 全局变量，存储当前正在被初始化的组件实例\r\nlet currentInstance = null\r\n// 该方法接收组件实例作为参数，并将该实例设置为 currentInstance\r\nfunction setCurrentInstance(instance) {\r\n    currentInstance = instance\r\n}\r\n\r\n// resolveProps 函数用于解析组件 props 和 attrs 数据\r\nfunction resolveProps(options, propsData) {\r\n    const props = {}\r\n    const attrs = {}\r\n    // 遍历为组件传递的 props 数据\r\n    for (const key in propsData) {\r\n        // 以字符串 on 开头的 props，无论是否显式地声明，都将其添加到 props数据中，而不是添加到 attrs 中\r\n        if (key in options || key.startsWith('on')) {\r\n            // 如果为组件传递的 props 数据在组件自身的 props 选项中有定义，则将其视为合法的 props\r\n            props[key] = propsData[key]\r\n        } else {\r\n            // 否则将其作为 attrs\r\n            attrs[key] = propsData[key]\r\n        }\r\n    }\r\n    // 最后返回 props 与 attrs 数据\r\n    return [ props, attrs ]\r\n}\r\n\r\n// 新旧得props变化是否\r\nfunction hasPropsChanged(prevProps, nextProps) {\r\n    const nextKeys = Object.keys(nextProps)\r\n    // 如果新旧 props 的数量变了，则说明有变化\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i]\r\n        // 有不相等的 props，则说明有变化\r\n        if (nextProps[key] !== prevProps[key]) return true\r\n    }\r\n    return false\r\n}\r\n\r\nfunction createRenderer(options) {\r\n    // 通过 options 得到操作 DOM 的 API\r\n    const {\r\n        createElement, \r\n        setElementText, \r\n        insert,\r\n        patchProps,\r\n        createText,\r\n        setText,\r\n        createComment,\r\n    } = options\r\n\r\n    // 卸载操作\r\n    function unmount(vnode) {\r\n        // 在卸载时，如果卸载的 vnode 类型为 Fragment，则需要卸载其 children\r\n        if (vnode.type === Fragment) {\r\n            vnode.children.forEach(c => unmount(c))\r\n            return\r\n        }\r\n        // 获取 el 的父元素\r\n        const parent = vnode.el.parentNode\r\n        // 调用 removeChild 移除元素\r\n        if (parent) parent.removeChild(vnode.el)\r\n    }\r\n\r\n    // 在这个作用域内定义的函数都可以访问那些 API\r\n    function mountElement(vnode, container, anchor) {\r\n        // 让 vnode.el 引用真实 DOM 元素\r\n        const el = vnode.el = createElement(vnode.type)\r\n        // 处理子节点，如果子节点是字符串，代表元素具有文本节点\r\n        if (typeof vnode.children === 'string') {\r\n            // 因此只需要设置元素的 textContent 属性即可\r\n            setElementText(el, vnode.children)\r\n        } else if(Array.isArray(vnode.children)) {\r\n            // 如果 children 是数组，则遍历每一个子节点，并调用 patch 函数挂载它们\r\n            vnode.children.forEach(child => {\r\n                patch(null, child, el)\r\n            })\r\n        }\r\n        // 如果 vnode.props 存在才处理它\r\n        if (vnode.props) {\r\n            // 遍历 vnode.props\r\n            for (const key in vnode.props) {\r\n                // 调用 patchProps 函数即可\r\n                patchProps(el, key, null, vnode.props[key])\r\n            }\r\n        }\r\n        // 调用 insert 函数将元素插入到容器内\r\n        insert(el, container, anchor)\r\n    }\r\n\r\n    // 挂载组件\r\n    function mountComponent(vnode, container, anchor) {\r\n         // 通过 vnode 获取组件的选项对象，即 vnode.type\r\n         const componentOptions = vnode.type\r\n         // 获取组件的渲染函数 render\r\n         const { render, data, setup, props: propsOption, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated } = componentOptions\r\n         // 在这里调用 beforeCreate 钩子\r\n         beforeCreate && beforeCreate()\r\n         // 调用 data 函数得到原始数据，并调用 reactive 函数将其包装为响应式数据\r\n         const state = data ? reactive(data()) : null\r\n         // 调用 resolveProps 函数解析出最终的 props 数据与 attrs 数据\r\n         const [props, attrs] = resolveProps(propsOption, vnode.props)\r\n          // 直接使用编译好的 vnode.children 对象作为 slots 对象即可\r\n          const slots = vnode.children || {}\r\n         // 定义组件实例，一个组件实例本质上就是一个对象，它包含与组件有关的状态信息\r\n         const instance = {\r\n            // 组件自身的状态数据，即 data\r\n            state,\r\n            // 将解析出的 props 数据包装为 shallowReactive 并定义到组件实例上\r\n            props: shallowReactive(props),\r\n            // 一个布尔值，用来表示组件是否已经被挂载，初始值为 false\r\n            isMounted: false,\r\n            // 组件所渲染的内容，即子树（subTree）\r\n            subTree: null,\r\n            slots,\r\n            // 在组件实例中添加 mounted 数组，用来存储通过 onMounted 函数注册的生命周期钩子函数\r\n            mounted: []\r\n         }\r\n         // 定义 emit 函数，它接收两个参数, event: 事件名称, payload: 传递给事件处理函数的参数\r\n         function emit(event, ...payload) {\r\n            // 根据约定对事件名称进行处理，例如 change --> onChange\r\n            const eventName = `on${event[0].toUpperCase() + event.slice(1)}`\r\n            // 根据处理后的事件名称去 props 中寻找对应的事件处理函数\r\n            const handler = instance.props[eventName]\r\n            if (handler) {\r\n                // 调用事件处理函数并传递参数\r\n                handler(...payload)\r\n            } else {\r\n                console.error('事件不存在')\r\n            }\r\n         }\r\n\r\n         // 在调用 setup 函数之前，设置当前组件实例\r\n         setCurrentInstance(instance)\r\n         function onMounted(fn) {\r\n            if (currentInstance) {\r\n                // 将生命周期函数添加到 instance.mounted 数组中\r\n                currentInstance.mounted.push(fn)\r\n            } else {\r\n                console.error('onMounted 函数只能在 setup 中调用')\r\n            }\r\n         }\r\n         // setupContext，由于我们还没有讲解 emit 和 slots，所以暂时只需要attrs\r\n         const setupContext = { attrs, emit, slots, onMounted }\r\n         // 调用 setup 函数，将只读版本的 props 作为第一个参数传递，避免用户意外地修改 props 的值，将 setupContext 作为第二个参数传递\r\n         const setupResult = setup(shallowReadonly(instance.props), setupContext)\r\n         // 在 setup 函数执行完毕之后，重置当前组件实例\r\n         setCurrentInstance(null)\r\n         // setupState 用来存储由 setup 返回的数据\r\n         let setupState = null\r\n         // 如果 setup 函数的返回值是函数，则将其作为渲染函数\r\n         if (typeof setupResult === 'function') {\r\n            if (render) console.error('setup 函数返回渲染函数，render 选项将被忽略')\r\n            // 将 setupResult 作为渲染函数\r\n            render = setupResult\r\n         } else {\r\n            // 如果 setup 的返回值不是函数，则作为数据状态赋值给 setupState\r\n            setupState = setupResult\r\n         }\r\n         // 将组件实例设置到 vnode 上，用于后续更新\r\n         vnode.component = instance\r\n         // 创建渲染上下文对象，本质上是组件实例的代理\r\n         const renderContext = new Proxy(instance, {\r\n            get(t, k, r) {\r\n                // 取得组件自身状态与 props 数据\r\n                const { state, props, slots } = t\r\n                // 当 k 的值为 $slots 时，直接返回组件实例上的 slots\r\n                if (k === '$slots') return slots\r\n                if (state && k in state) {\r\n                    // 先尝试读取自身状态数据\r\n                    return state[k]\r\n                } else if (k in props) { \r\n                    // 如果组件自身没有该数据，则尝试从 props 中读取\r\n                    return props[k]\r\n                } else if (setupState && k in setupState){\r\n                    // 渲染上下文需要增加对 setupState 的支持\r\n                    return setupState[k]\r\n                } else {\r\n                    console.error('不存在')\r\n                }\r\n            },\r\n            set (t, k, v, r) {\r\n                const { state, props } = t\r\n                if (state && k in state) {\r\n                    state[k] = v\r\n                }  else if (k in props) {\r\n                    console.warn(`Attempting to mutate prop \"${k}\". Propsare readonly.`)\r\n                } else if (setupState && k in setupState) {\r\n                    // 渲染上下文需要增加对 setupState 的支持\r\n                    setupState[k] = v\r\n                } else {\r\n                    console.error('不存在')\r\n                }\r\n            }\r\n         })\r\n         // 在这里调用 created 钩子\r\n         created && created.call(renderContext)\r\n\r\n         // 将组件的 render 函数调用包装到 effect 内\r\n         effect(() => {\r\n            // 调用 render 函数时，将其 this 设置为 state， 从而 render 函数内部可以通过 this 访问组件自身状态数据\r\n            const subTree = render.call(state, state)\r\n            // 检查组件是否已经被挂载\r\n            if (!instance.isMounted) {\r\n                // 在这里调用 beforeMount 钩子\r\n                beforeMount && beforeMount.call(state)\r\n                // 初次挂载，调用 patch 函数第一个参数传递 null\r\n                patch(null, subTree, container, anchor)\r\n                // 重点：将组件实例的 isMounted 设置为 true，这样当更新发生时就不会再次进行挂载操作,而是会执行更新\r\n                instance.isMounted = true\r\n                // 在这里调用 mounted 钩子\r\n                mounted && mounted.call(state)\r\n            } else {\r\n                // 在这里调用 beforeUpdate 钩子\r\n                beforeUpdate && beforeUpdate.call(state)\r\n                // 当 isMounted 为 true 时，说明组件已经被挂载，只需要完成自更新即可，\r\n                // 所以在调用 patch 函数时，第一个参数为组件上一次渲染的子树，思是，使用新的子树与上一次渲染的子树进行打补丁操作\r\n                patch(instance.subTree, subTree, container, anchor)\r\n                // 在这里调用 updated 钩子\r\n                updated && updated.call(state)\r\n            }\r\n            // 更新组件实例的子树\r\n            instance.subTree = subTree       \r\n         }, {\r\n            // 指定该副作用函数的调度器为 queueJob 即可\r\n            scheduler: queueJob\r\n         })\r\n    }\r\n\r\n    // 简单diff算法\r\n    function simpleDiff(n1, n2, container) {\r\n        // 代码运行到这里，则说明新旧子节点都是一组子节点，这里涉及核心的Diff 算法\r\n        const oldChildren = n1.children\r\n        const newChildren = n2.children\r\n        // 用来存储寻找过程中遇到的最大索引值\r\n        let lastIndex = 0\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const newVNode = newChildren[i]\r\n            let j = 0\r\n            // 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点，初始值为 false，代表没找到\r\n            let find = false\r\n            // 遍历旧的 children \r\n            for (j; j < oldChildren.length; j++) {\r\n                const oldVNode = oldChildren[j]\r\n                // 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新\r\n                if (newVNode.key === oldVNode.key) {\r\n                    // 一旦找到可复用的节点，则将变量 find 的值设为 true\r\n                    find = true\r\n                    patch(oldVNode, newVNode, container)\r\n                    if (j < lastIndex) {\r\n                        // 如果当前找到的节点在旧 children 中的索引小于最大索引值lastIndex,说明该节点对应的真实 DOM 需要移动\r\n                        // 先获取 newVNode 的前一个 vnode，即 prevVNode\r\n                        const prevVNode = newChildren[i - 1]\r\n                        // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动\r\n                        if (prevVNode) {\r\n                            // 由于我们要将 newVNode 对应的真实 DOM 移动到prevVNode 所对应真实 DOM 后面，所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点\r\n                            const anchor = prevVNode.el.nextSibling\r\n                            // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，也就是 prevVNode 对应真实 DOM 的后面\r\n                            insert(newVNode.el, container, anchor)\r\n                        }\r\n                    } else {\r\n                        // 如果当前找到的节点在旧 children 中的索引不小于最大索引值，则更新 lastIndex 的值\r\n                        lastIndex = j\r\n                    }\r\n                    break // 这里需要 break\r\n                }\r\n            }\r\n            // 如果代码运行到这里，find 仍然为 false， 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点也就是说，当前 newVNode 是新增节点，需要挂载\r\n            if (!find) {\r\n                // 为了将节点挂载到正确位置，我们需要先获取锚点元素,首先获取当前 newVNode 的前一个 vnode 节点\r\n                const prevVNode = newChildren[i - 1]\r\n                let anchor = null\r\n                if (prevVNode) {\r\n                    // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素\r\n                    anchor = prevVNode.el.nextSibling\r\n                } else {\r\n                    // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点,这时我们使用容器元素的 firstChild 作为锚点\r\n                    anchor = container.firstChild\r\n                }\r\n                // 挂载 newVNod\r\n                patch(null, newVNode, container, anchor)\r\n            }\r\n        }\r\n        // 上一步的更新操作完成后,遍历旧的一组子节点\r\n        for (let i = 0; i < oldChildren.length; i++) {\r\n            const oldVNode = oldChildren[i]\r\n            // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点\r\n            const has = newChildren.find(vnode => vnode.key === oldVNode.key)\r\n            if (!has) {\r\n                // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点调用 unmount 函数将其卸载\r\n                unmount(oldVNode)\r\n            }\r\n        }\r\n    }\r\n\r\n    // 双端算法\r\n    function patchKeyedChildren(n1, n2, container) {\r\n        const oldChildren = n1.children\r\n        const newChildren = n2.children\r\n        // 四个索引值\r\n        let oldStartIdx = 0\r\n        let oldEndIdx = oldChildren.length - 1\r\n        let newStartIdx = 0\r\n        let newEndIdx = newChildren.length - 1\r\n        // 四个索引指向的 vnode 节点\r\n        let oldStartVNode = oldChildren[oldStartIdx]\r\n        let oldEndVNode = oldChildren[oldEndIdx]\r\n        let newStartVNode = newChildren[newStartIdx]\r\n        let newEndVNode = newChildren[newEndIdx]\r\n\r\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            // 增加两个判断分支，如果头尾部节点为 undefined，则说明该节点已经被处理过了，直接跳到下一个位置\r\n            if (!oldStartVNode) {\r\n                oldStartVNode = oldChildren[++oldStartIdx]\r\n            } else if (!oldEndVNode) {\r\n                oldEndVNode = oldChildren[--oldEndIdx]\r\n            } else if (oldStartVNode.key === newStartVNode.key) {\r\n                // 第一步：oldStartVNode 和 newStartVNode 比较\r\n                // 调用 patch 函数在 oldStartVNode 与 newStartVNode 之间打补丁\r\n                patch(oldStartVNode, newStartVNode, container)\r\n                // 更新相关索引，指向下一个位置\r\n                oldStartVNode = oldChildren[++oldStartIdx]\r\n                newStartVNode = newChildren[++newStartIdx]\r\n            } else if (oldEndVNode.key === newEndVNode.key) {\r\n                // 第二步：oldEndVNode 和 newEndVNode 比较\r\n                // 节点在新的顺序中仍然处于尾部，不需要移动，但仍需打补丁\r\n                patch(oldEndVNode, newEndVNode, container)\r\n                // 更新索引和头尾部节点变量\r\n                oldEndVNode = oldChildren[--oldEndIdx]\r\n                newEndVNode = newChildren[--newEndIdx]\r\n            } else if (oldStartVNode.key === newEndVNode.key) {\r\n                // 第三步：oldStartVNode 和 newEndVNode 比较\r\n                // 调用 patch 函数在 oldStartVNode 和 newEndVNode 之间打补丁\r\n                patch(oldStartVNode, newEndVNode, container)\r\n                // 将旧的一组子节点的头部节点对应的真实 DOM 节点 oldStartVNode.el移动到旧的一组子节点的尾部节点对应的真实 DOM 节点后面\r\n                insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)\r\n                // 更新相关索引到下一个位置\r\n                oldStartVNode = oldChildren[++oldStartIdx]\r\n                newEndVNode = newChildren[--newEndIdx]\r\n            } else if (oldEndVNode.key === newStartVNode.key) {\r\n                // 第四步：oldEndVNode 和 newStartVNode 比较, 仍然需要调用 patch 函数进行打补丁\r\n                patch(oldEndVNode, newStartVNode, container)\r\n                // 移动 DOM 操作, oldEndVNode.el 移动到 oldStartVNode.el 前面\r\n                insert(oldEndVNode.el, container, oldStartVNode.el)\r\n                // 移动 DOM 完成后，更新索引值，并指向下一个位置 \r\n                oldEndVNode = oldChildren[--oldEndIdx]\r\n                newStartVNode = newChildren[++newStartIdx]\r\n            } else {\r\n                // 遍历旧的一组子节点，试图寻找与 newStartVNode 拥有相同 key 值的节点,idxInOld 就是新的一组子节点的头部节点在旧的一组子节点中的索引\r\n                const idxInOld = oldChildren.findIndex(node => node.key === newStartVNode.key)\r\n                // idxInOld 大于 0，说明找到了可复用的节点，并且需要将其对应的真实移动到头部\r\n                if (idxInOld > 0) {\r\n                    // idxInOld 位置对应的 vnode 就是需要移动的节点\r\n                    const vnodeToMove = oldChildren[idxInOld]\r\n                    // 不要忘记除移动操作外还应该打补丁\r\n                    patch(vnodeToMove, newStartVNode, container)\r\n                    // 将 vnodeToMove.el 移动到头部节点 oldStartVNode.el 之前，因此使用后者作为锚点\r\n                    insert(vnodeToMove.el, container, oldStartVNode.el)\r\n                    // 由于位置 idxInOld 处的节点所对应的真实 DOM 已经移动到了别处，因此将其设置为 undefined\r\n                    oldChildren[idxInOld] = undefined\r\n                    // 最后更新 newStartIdx 到下一个位置\r\n                    newStartVNode = newChildren[++newStartIdx]\r\n                } else {\r\n                    // 将 newStartVNode 作为新节点挂载到头部，使用当前头部节点oldStartVNode.el 作为锚点\r\n                    patch(null, newStartVNode, container, oldStartVNode.el)\r\n                }\r\n                newStartVNode = newChildren[++newStartIdx]\r\n            }\r\n        }\r\n        // 循环结束后检查索引值的情况\r\n        if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {\r\n            // 添加新节点\r\n            // 如果满足条件，则说明有新的节点遗留，需要挂载它们\r\n            for (let i = newStartIdx; i <= newEndIdx; i++) {\r\n                patch(null, newChildren[i], container, oldStartVNode.el)\r\n            }\r\n        } else if (newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx) {\r\n            // 移除操作\r\n            for (let i = oldStartIdx; i <= oldEndIdx; i++) {\r\n                unmount(oldChildren[i])\r\n            }\r\n        }\r\n    }\r\n\r\n    // 快速算法\r\n    function fastDiff(n1, n2, container) {\r\n        const oldChildren = n1.children\r\n        const newChildren = n2.children\r\n        // 处理相同的前置节点, 索引 j 指向新旧两组子节点的开头\r\n        let j = 0\r\n        let oldVNode = oldChildren[j]\r\n        let newVNode = newChildren[j]\r\n        // while 循环向后遍历，直到遇到拥有不同 key 值的节点为止\r\n        while (oldVNode.key === newVNode.key) {\r\n            // 调用 patch 函数进行更新\r\n            patch(oldVNode, newVNode, container)\r\n            // 更新索引 j，让其递增\r\n            j++\r\n            oldVNode = oldChildren[j]\r\n            newVNode = newChildren[j]\r\n        }\r\n        // 更新相同的后置节点,索引 oldEnd 指向旧的一组子节点的最后一个节点\r\n        let oldEnd = oldChildren.length - 1\r\n        // 索引 newEnd 指向新的一组子节点的最后一个节点\r\n        let newEnd = newChildren.length - 1\r\n        oldVNode = oldChildren[oldEnd]\r\n        newVNode = newChildren[newEnd]\r\n        // while 循环从后向前遍历，直到遇到拥有不同 key 值的节点为止\r\n        while (oldVNode.key === newVNode.key) {\r\n            // 调用 patch 函数进行更新\r\n            patch(oldVNode, newVNode, container)\r\n            // 递减 oldEnd 和 nextEnd\r\n            oldEnd--\r\n            newEnd--\r\n            oldVNode = oldChildren[oldEnd]\r\n            newVNode = newChildren[newEnd]\r\n        }\r\n        // 预处理完毕后，如果满足如下条件，则说明从 j --> newEnd 之间的节点应作为新节点插入\r\n        if (j > oldEnd && j <= newEnd) {\r\n            // 锚点的索引\r\n            const anchorIndex = newEnd + 1\r\n            // 锚点元素\r\n            const anchor = anchorIndex < newChildren.length ? newChildren[anchorIndex].el : null\r\n            // 采用 while 循环，调用 patch 函数逐个挂载新增节点\r\n            while (j <= newEnd) {\r\n                patch(null, newChildren[j++], container, anchor)\r\n            }\r\n        } else if (j > newEnd && j <= oldEnd) {\r\n            // j -> oldEnd 之间的节点应该被卸载\r\n            while (j <= oldEnd) {\r\n                unmount(oldChildren[j++])\r\n            }\r\n        } else {\r\n            // 构造 source 数组,新的一组子节点中剩余未处理节点的数量\r\n            const count = newEnd - j + 1\r\n            const source = new Array(count)\r\n            source.fill(-1)\r\n            // oldStart 和 newStart 分别为起始索引，即 j\r\n            const oldStart = j\r\n            const newStart = j\r\n            // 新增两个变量，moved 和 pos\r\n            let moved = false\r\n            let pos = 0\r\n            // 构建索引表\r\n            const keyIndex = {}\r\n            for(let i = newStart; i <= newEnd; i++) {\r\n                keyIndex[newChildren[i].key] = i\r\n            }\r\n            // 新增 patched 变量，代表更新过的节点数量\r\n            let patched = 0\r\n            // 遍历旧的一组子节点中剩余未处理的节点\r\n            for(let i = oldStart; i <= oldEnd; i++) {\r\n                oldVNode = oldChildren[i]\r\n                // 如果更新过的节点数量小于等于需要更新的节点数量，则执行更新\r\n                if (patched <= count) {\r\n                    // 通过索引表快速找到新的一组子节点中具有相同 key 值的节点位置\r\n                    const k = keyIndex[oldVNode.key]\r\n                    if (typeof k !== 'undefined') {\r\n                        newVNode = newChildren[k]\r\n                        // 调用 patch 函数完成更新\r\n                        patch(oldVNode, newVNode, container)\r\n                        // 每更新一个节点，都将 patched 变量 +1\r\n                        patched++\r\n                        // 填充 source 数组\r\n                        source[k - newStart] = i\r\n                        // 判断节点是否需要移动\r\n                        if (k < pos) {\r\n                            moved = true\r\n                        } else {\r\n                            pos = k\r\n                        }\r\n                    } else {\r\n                        // 没找到\r\n                        unmount(oldVNode)\r\n                    }\r\n                } else {\r\n                    // 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点\r\n                    unmount(oldVNode)\r\n                }\r\n            }\r\n            if (moved) {\r\n                // 如果 moved 为真，则需要进行 DOM 移动操作\r\n                // 计算最长递增子序列\r\n                const seq = lis(source)\r\n                // s 指向最长递增子序列的最后一个元素\r\n                let s = seq.length - 1\r\n                // i 指向新的一组子节点的最后一个元素\r\n                let i = count - 1\r\n                // for 循环使得 i 递减\r\n                for (i; i >= 0; i--) {\r\n                    if (source[i] === -1) {\r\n                        // 说明索引为 i 该节点在新 children 中的真实位置索引\r\n                        const pos = i + newStart\r\n                        const newVNode = newChildren[pos]\r\n                        // 该节点的下一个节点的位置索引\r\n                        const nextPos = pos + 1\r\n                        // 锚点\r\n                        const anchor = nextPos < newChildren.length ? newChildren[nextPos].el : null\r\n                        // 挂载\r\n                        patch(null, newVNode, container, anchor)\r\n\r\n                    } else if (i !== seq[s]) {\r\n                        // 如果节点的索引 i 不等于 seq[s] 的值，说明该节点需要移动\r\n                        // 该节点在新的一组子节点中的真实位置索引\r\n                        const pos = i + newStart\r\n                        const newVNode = newChildren[pos]\r\n                        // 该节点的下一个节点的位置索引\r\n                        const nextPos = pos + 1\r\n                        // 锚点\r\n                        const anchor = nextPos < newChildren.length ? newChildren[nextPos].el : null\r\n                        // 移动\r\n                        insert(newVNode.el, container, anchor)\r\n                    } else {\r\n                        // 当 i === seq[s] 时，说明该位置的节点不需要移动,只需要让 s 指向下一个位置\r\n                        s--\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    // 更新子节点\r\n    function patchChildren(n1, n2, container) {\r\n        // 判断新子节点的类型是否是文本节点\r\n        if (typeof n2.children === 'string'){\r\n            // 旧子节点的类型有三种可能：没有子节点、文本子节点以及一组子节点, 只有当旧子节点为一组子节点时，才需要逐个卸载，其他情况下什么都不需要\r\n            if (Array.isArray(n1.children)) {\r\n                n1.children.forEach((c) => unmount(c))\r\n            }\r\n            // 最后将新的文本节点内容设置给容器元素\r\n            setElementText(container, n2.children)\r\n        }  else if (Array.isArray(n2.children)) {\r\n            // 说明新子节点是一组子节点, 判断旧子节点是否也是一组子节点\r\n            if (Array.isArray(n1.children)) {\r\n                // // 简单算法\r\n                // simpleDiff(n1, n2, container)\r\n                // 双端算法\r\n                // 封装 patchKeyedChildren 函数处理两组子节点\r\n                // patchKeyedChildren(n1, n2, container)\r\n                // 快速算法\r\n                fastDiff(n1, n2, container)\r\n            } else {\r\n                // 此时：旧子节点要么是文本子节点，要么不存在,但无论哪种情况，我们都只需要将容器清空，然后将新的一组子节点逐个挂载\r\n                setElementText(container, '')\r\n                n2.children.forEach(c => patch(null, c, container))\r\n            }\r\n        } else {\r\n            // 代码运行到这里，说明新子节点不存在, 旧子节点是一组子节点，只需逐个卸载即可\r\n            if (Array.isArray(n1.children)) {\r\n                n1.children.forEach(c => unmount(c))\r\n            } else if (typeof n1.children === 'string') {\r\n                // 旧子节点是文本子节点，清空内容即可\r\n                setElementText(container, '')\r\n            }\r\n        }\r\n    }\r\n\r\n    // 更新\r\n    function patchElement(n1, n2) {\r\n        const el = n2.el = n1.el\r\n        const oldProps = n1.props\r\n        const newProps = n2.props\r\n        // 第一步：更新 props\r\n        for (const key in newProps) {\r\n            if (newProps[key] !== oldProps[key]) {\r\n                patchProps(el, key, oldProps[key], newProps[key])\r\n            }\r\n        }\r\n        for (const key in oldProps) {\r\n            if (!(key in newProps)) {\r\n                patchProps(el, key, oldProps[key], null)\r\n            }\r\n        }\r\n        // 第二步：更新 children\r\n        patchChildren(n1, n2, el)\r\n    }\r\n\r\n    // 更新组件\r\n    function patchComponent(n1, n2, anchor) {\r\n        // 获取组件实例，即 n1.component，同时让新的组件虚拟节点 n2.component也指向组件实例\r\n        const instance = (n2.component = n1.component)\r\n        // 获取当前的 props 数据\r\n        const { props } = instance\r\n        // 调用 hasPropsChanged 检测为子组件传递的 props 是否发生变化，如果没有变化，则不需要更新\r\n        if (hasPropsChanged(n1.props, n2.props)) {\r\n            // 调用 resolveProps 函数重新获取 props 数据\r\n            const [ nextProps ] = resolveProps(n2.type.props, n2.props)\r\n            // 更新 props\r\n            for (const k in nextProps) {\r\n                props[k] = nextProps[k]\r\n            }\r\n            // 删除不存在的 props\r\n            for (const k in props) {\r\n                if (!(k in nextProps)) delete props[k]\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // n1：旧 vnode, n2：新 vnode, container：容器\r\n    function patch(n1, n2, container, anchor) {\r\n        // 如果 n1 存在，则对比 n1 和 n2 的类型\r\n        if (n1 && n1.type !== n2.type) {\r\n            // 如果新旧 vnode 的类型不同，则直接将旧 vnode 卸载\r\n            unmount(n1)\r\n            n1 = null\r\n        }\r\n        // 代码运行到这里，证明 n1 和 n2 所描述的内容相同\r\n        const { type } = n2\r\n        // 如果 n2.type 的值是字符串类型，则它描述的是普通标签元素\r\n        if (typeof type === 'string') {\r\n             // 如果 n1 不存在，意味着挂载，则调用 mountElement 函数完成挂载\r\n            if (!n1) {\r\n                // 挂载时将锚点元素作为第三个参数传递给 mountElement 函数\r\n                mountElement(n2, container, anchor)\r\n            } else {\r\n                // n1 存在，意味着打补丁\r\n                patchElement(n1, n2)\r\n            }\r\n        } else if (type === Text) {\r\n            // 如果新 vnode 的类型是 Text，则说明该 vnode 描述的是文本节点,如果没有旧节点，则进行挂载\r\n            if (!n1) {\r\n                // 使用 createTextNode 创建文本节点\r\n                const el = n2.el = createText(n2.children)\r\n                // 将文本节点插入到容器中\r\n                insert(el, container)\r\n            } else {\r\n                // 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即可\r\n                const el = n2.el = n1.el\r\n                if (n2.children !== n1.children) {\r\n                    setText(el, n2.children)\r\n                }\r\n            }\r\n        } else if (type === Comment) {\r\n            // 如果新 vnode 的类型是 Text，则说明该 vnode 描述的是文本节点,如果没有旧节点，则进行挂载\r\n            if (!n1) {\r\n                // 使用 createTextNode 创建文本节点\r\n                const el = n2.el = createComment(n2.children)\r\n                // 将文本节点插入到容器中\r\n                insert(el, container)\r\n            } else {\r\n                // 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即可\r\n                const el = n2.el = n1.el\r\n                if (n2.children !== n1.children) {\r\n                    setText(el, n2.children)\r\n                }\r\n            }\r\n        } else if (type === Fragment) {\r\n            if (!n1) {\r\n                // 如果旧 vnode 不存在，则只需要将 Fragment 的 children 逐个挂载即可\r\n                n2.children.forEach(c => patch(null, c, container))\r\n            } else {\r\n                // 如果旧 vnode 存在，则只需要更新 Fragment 的 children 即可\r\n                patchChildren(n1, n2, container)\r\n            }\r\n        } else if(typeof type === 'object') {\r\n            // 如果 n2.type 的值的类型是对象，则它描述的是组件\r\n            if (!n1) {\r\n                // 挂载组件\r\n                mountComponent(n2, container, anchor)\r\n            } else {\r\n                // 更新组件\r\n                patchComponent(n1, n2, anchor)\r\n            }\r\n        }\r\n       \r\n    }\r\n\r\n    function render(vnode, container) {\r\n        if (vnode) {\r\n            // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数，进行打补\r\n            patch(container._vnode, vnode, container)\r\n        } else {\r\n            if (container._vnode) {\r\n                // 调用 unmount 函数卸载 vnode\r\n                unmount(container._vnode)\r\n            }\r\n        }\r\n        // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\r\n        container._vnode = vnode\r\n    }\r\n\r\n    function hydrate(vnode, container) {\r\n\r\n    }\r\n\r\n    return {\r\n        render,\r\n        hydrate,\r\n    }\r\n}\r\n\r\nexport default createRenderer","import flushJob, { jobQueue } from './observer/scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './observer/effect'\r\nimport computed from './observer/computed'\r\nimport { track, trigger, ITERATE_KEY } from './observer/responsive'\r\nimport watch from './observer/watch'\r\nimport { reactive, shallowReactive, readonly } from './observer/reactive'\r\nimport { ref, toRefs, toRef, proxyRefs } from './observer/ref'\r\nimport createRenderer from './instance/renderer'\r\nimport { \r\n    createElement, \r\n    setElementText, \r\n    insert, \r\n    patchProps, \r\n    createText, \r\n    setText, \r\n    Text, \r\n    Comment,\r\n    createComment,\r\n    Fragment,\r\n} from './vdom/create-element'\r\n\r\nconst renderer = createRenderer({\r\n    createElement, setElementText, insert, patchProps, createText, setText, createComment\r\n})\r\n\r\n// const obj = {}\r\n// const proto = { bar: 1 }\r\n// const child = reactive(obj)\r\n// const parent = reactive(proto)\r\n//  // 使用 parent 作为 child 的原型\r\n//  Object.setPrototypeOf(child, parent)\r\n//  effect(() => {\r\n//     console.log(child.bar)\r\n//  })\r\n//   // 修改 child.bar 的值\r\n//   child.bar = 2 // 会导致副作用函数重新执行两次\r\n\r\n// 深响应\r\n// const obj = reactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // 修改 obj.foo.bar 的值，并不能触发响应\r\n// obj.foo.bar = 2\r\n\r\n// 浅响应\r\n// const obj = shallowReactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // obj.foo 是响应的，可以触发副作用函数重新执行\r\n// obj.foo = { bar: 2 }\r\n// // obj.foo.bar 不是响应的，不能触发副作用函数重新执行\r\n// obj.foo.bar = 3\r\n\r\n// 只读\r\n// const obj = readonly({ foo: 1 })\r\n// effect(() => {\r\n//     obj.foo // 可以读取值，但是不需要在副作用函数与数据之间建立响应联系\r\n// })\r\n// // 尝试修改数据，会得到警告\r\n// obj.foo = 2\r\n\r\n// // set\r\n// const p = reactive(new Set([1, 2, 3]))\r\n// // 第一个副作用函数\r\n// effect(() => {\r\n//     console.log(p.size)\r\n// })\r\n// p.add(4)\r\n// p.delete(1)\r\n\r\n// map\r\n// const p = reactive(new Map([['key', 1]]))\r\n// effect(() => {\r\n//     console.log(p.get('key'))\r\n// })\r\n// p.set('key', 2) // 触发响应\r\n\r\n// 迭代器\r\n// const p = reactive(new Map([\r\n//     ['key1', 'value1'],\r\n//     ['key2', 'value2']\r\n// ]))\r\n// effect(() => {\r\n//     for (const [key, value] of p) {\r\n//         console.log(key, value)\r\n//     }\r\n// })\r\n// p.set('key3', 'value3')\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n//  watch(\r\n//     // getter 函数\r\n//     () => obj.foo,\r\n//     // 回调函数\r\n//     async (newValue, oldValue, onInvalidate) => {\r\n//         console.log(newValue, oldValue)\r\n//     },\r\n//     {\r\n//         // 回调函数会在 watch 创建时立即执行一次\r\n//         immediate: true,\r\n//         // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n//         // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n//     }\r\n// )\r\n\r\n\r\n// 原始值\r\n//  const name = ref('vue')\r\n//  effect(() => {\r\n//     console.log(name.value)\r\n//  })\r\n//  // 修改值可以触发响应\r\n//  name.value = 'vue3'\r\n\r\n//  const obj = reactive({ foo: 1, bar: 2 })\r\n//  effect(() => {\r\n//     console.log(proxyRefs({...toRefs(obj)}))\r\n\r\n//  })\r\n//  obj.foo = 2\r\n//  obj.bar = 3 \r\n\r\n// const vnode = {\r\n//     type: 'h1',\r\n//     // 使用 props 描述一个元素的属性\r\n//     props: {\r\n//         id: 'foo',\r\n//         // 使用 onXxx 描述事件\r\n//        onClick: [\r\n//             // 第一个事件处理函数\r\n//             () => {\r\n//                 alert('clicked 1')\r\n//             },\r\n//             // 第二个事件处理函数\r\n//             () => {\r\n//                 alert('clicked 2')\r\n//             }\r\n//         ],\r\n//         onContextmenu: () => {\r\n//             alert('contextmenu')\r\n//         }\r\n//     },\r\n//     children: [{\r\n//         type: 'p',\r\n//         children: 'hello' \r\n//     }, {\r\n//         // 描述文本节点\r\n//         type: Text,\r\n//         children: '我是文本内容'\r\n//     }, {\r\n//         // 描述注释节点\r\n//         type: Comment,\r\n//         children: '我是注释内容'\r\n//     }, {\r\n//         type: 'ul',\r\n//         children: [{\r\n//             type: Fragment,\r\n//             children: [\r\n//                 { type: 'li', children: 'text 1', key: 1 },\r\n//                 { type: 'li', children: 'text 2', key: 2 },\r\n//                 { type: 'li', children: 'text 3', key: 3 }\r\n//             ]\r\n//         }]\r\n//     }]\r\n// }\r\n// effect(() => {\r\n//     renderer.render(vnode, document.querySelector('#app'))\r\n// }) \r\n\r\n// const oldVNode = { \r\n//     type: 'div',\r\n//     children: [\r\n//         { type: 'p', children: '1', key: 1 },\r\n//         { type: 'p', children: '2', key: 2 },\r\n//         { type: 'p', children: 'hello', key: 3 },\r\n//         // { type: 'p', children: '4', key: 4 },\r\n//     ]\r\n// }\r\n\r\n// const newVNode = {\r\n//     type: 'div',\r\n//     children: [\r\n//         { type: 'p', children: '4', key: 4 },\r\n//         { type: 'p', children: '2', key: 2 },\r\n//         { type: 'p', children: '1', key: 1 },\r\n//         { type: 'p', children: 'world', key: 3 },\r\n//     ]\r\n// }\r\n\r\n//  // 首次挂载\r\n//  renderer.render(oldVNode, document.querySelector('#app'))\r\n//  setTimeout(() => {\r\n//     // 1 秒钟后更新\r\n//     renderer.render(newVNode, document.querySelector('#app'))\r\n//  }, 1000)\r\n\r\n\r\n\r\n // MyComponent 是一个组件，它的值是一个选项对象\r\n const MyComponent = {\r\n    name: 'MyComponent',\r\n    // 组件接收名为 title 的 props，并且该 props 的类型为 String\r\n    props: {\r\n        title: String,\r\n    },\r\n    data() {\r\n        return { foo: 'hello world' }\r\n    },\r\n    setup() {\r\n\r\n    },\r\n    // 组件的渲染函数，其返回值必须为虚拟 DOM\r\n    render() {\r\n        // 返回虚拟 DOM\r\n        return [\r\n            {\r\n                type: 'header',\r\n                children: [this.$slots.header()]\r\n            },\r\n            {\r\n                type: 'body',\r\n                children: [this.$slots.body()]\r\n            },\r\n            {\r\n                type: 'footer',\r\n                children: [this.$slots.footer()]\r\n            }\r\n        ]\r\n    }\r\n }\r\n// 该 vnode 用来描述组件，type 属性存储组件的选项对象\r\nconst vnode = {\r\n    // type: MyComponent,\r\n    props: {\r\n        title: 'A big Title',\r\n        // other: this.val\r\n    },\r\n    render() {\r\n        return {\r\n            type: MyComponent,\r\n            // 组件的 children 会被编译成一个对象\r\n            children: {\r\n                header() {\r\n                    return { type: 'h1', children: '我是标题' }\r\n                },\r\n                body() {\r\n                    return { type: 'section', children: '我是内容' }\r\n                },\r\n                footer() {\r\n                    return { type: 'p', children: '我是注脚' }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nrenderer.render(vnode, document.querySelector('#app'))"],"names":["Promise","resolve","activeEffect","effectStack","effect","fn","effectFn","cleanup","push","res","pop","length","options","arguments","undefined","deps","lazy","i","toString","Object","prototype","toTypeString","value","call","isMap","val","isSet","lis","nums","_step","tails","_iterator","_createForOfIteratorHelper","s","n","done","num","l","r","mid","Math","floor","err","e","f","reactiveMap","Map","arrayInstrumentations","shouldTrack","forEach","method","originMethod","Array","_len","args","_key","apply","this","raw","iterationMethod","wrap","_typeof","reactive","target","itr","Symbol","iterator","track","ITERATE_KEY","next","_itr$next","valuesIterationMethod","values","_defineProperty","_itr$next2","keysIterationMethod","keys","MAP_KEY_ITERATE_KEY","_itr$next3","_len2","_key2","_mutableInstrumentati","add","key","hadKey","has","trigger","delete","_delete","get","had","set","oldValue","rawValue","callback","thisArg","_this","v","k","mutableInstrumentations","createReactive","obj","isShallow","isReadonly","Proxy","receiver","Reflect","isArray","hasOwnProperty","readonly","ownKeys","newVal","oldVal","type","console","warn","concat","Number","deleteProperty","existionProxy","proxy","shallowReactive","bucket","WeakMap","depsMap","Set","effectsToRun","iterateEffects","effects","lengthEffects","iterateEffectKeys","scheduler","Text","Comment","Fragment","createElement","tag","document","setElementText","el","text","textContent","insert","parent","anchor","getElementById","insertBefore","createText","createTextNode","setText","nodeValue","createComment","shouldSetAsProps","tagName","patchProps","prevValue","nextValue","invoker","test","_vei","name","slice","toLowerCase","timeStamp","attached","performance","now","addEventListener","removeEventListener","className","setAttribute","queue","isFlushing","p","queueJob","job","then","clear","currentInstance","setCurrentInstance","instance","resolveProps","propsData","props","attrs","startsWith","hasPropsChanged","prevProps","nextProps","nextKeys","createRenderer","unmount","vnode","children","parentNode","removeChild","mountComponent","container","componentOptions","render","data","setup","propsOption","beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","state","_resolveProps2","_slicedToArray","slots","isMounted","subTree","setupContext","emit","event","eventName","toUpperCase","handler","payload","error","onMounted","setupResult","shallowReadonly","setupState","renderContext","_readOnlyError","component","t","patch","patchChildren","n1","n2","fastDiff","oldChildren","newChildren","j","oldVNode","newVNode","oldEnd","newEnd","anchorIndex","count","source","oldStart","fill","newStart","moved","pos","keyIndex","patched","seq","nextPos","c","patchElement","oldProps","newProps","mountElement","child","patchComponent","_vnode","hydrate","renderer","MyComponent","title","String","foo","$slots","header","body","footer","querySelector"],"mappings":"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"}