{"version":3,"file":"vue.esm.js","sources":["../src/observer/effect.js","../src/observer/scheduler.js","../src/util.js","../src/observer/reactive.js","../src/observer/responsive.js","../src/instance/renderer.js","../src/index.js"],"sourcesContent":["// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","const toString = Object.prototype.toString\r\n\r\nexport const toTypeString = (value) => toString.call(value)\r\n\r\n// 判断map类型\r\nexport const isMap = (val) => toTypeString(val) === '[object Map]'\r\n// 判断set类型\r\nexport const isSet = (val) => toTypeString(val) === '[object Set]'","import { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './responsive'\r\nimport { isMap, isSet } from '../util'\r\n\r\nconst TriggerType = { \r\n    SET: 'SET',\r\n    ADD: 'ADD'\r\n }\r\n // 定义一个 Map 实例，存储原始对象到代理对象的映射\r\nconst reactiveMap = new Map()\r\n\r\nconst arrayInstrumentations = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\r\n        let res = originMethod.apply(this, args)\r\n        if (res === false || res === -1) {\r\n            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值\r\n            res = originMethod.apply(this.raw, args)\r\n        }\r\n        // 返回最终结果\r\n        return res\r\n    }\r\n})\r\n\r\n // 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪\r\n export let shouldTrack = true\r\n  // 重写数组的 push、pop、shift、unshift 以及 splice 方法\r\n ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {\r\n    // 取得原始 push 方法\r\n    const originMethod = Array.prototype[method]\r\n    // 重写\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // 在调用原始方法之前，禁止追踪\r\n        shouldTrack = false\r\n        // push 方法的默认行为\r\n        let res = originMethod.apply(this, args)\r\n        // 在调用原始方法之后，恢复原来的行为，即允许追踪\r\n        shouldTrack = true\r\n        return res\r\n    }\r\n })\r\n\r\n // 抽离为独立的函数，便于复用\r\n function iterationMethod() {\r\n    const target = this.raw\r\n    const itr = target[Symbol.iterator]()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val): val\r\n    track(target, ITERATE_KEY)\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                value:  value ? [wrap(value[0]), wrap(value[1])] : value,\r\n                done,\r\n            }\r\n        }\r\n    }\r\n }\r\n\r\n function valuesIterationMethod() {\r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 通过 target.values 获取原始迭代器方法\r\n    const itr = target.values()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    track(target, ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n function keysIterationMethod() { \r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 获取原始迭代器方法\r\n    const itr = target.keys()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系\r\n    track(target, MAP_KEY_ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n // 定义一个对象，将自定义的 add 方法定义到该对象下\r\n const mutableInstrumentations = {\r\n    add(key) {\r\n        // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象\r\n        const target = this.raw\r\n        // 先判断值是否已经存在\r\n        const hadKey = target.has(key)\r\n        // 通过原始数据对象执行 add 方法添加具体的值，注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的\r\n        const res = target.add(key) \r\n        // 调用 trigger 函数触发响应，并指定操作类型为 ADD\r\n        if(!hadKey) {\r\n            trigger(target, key, 'ADD')\r\n        }\r\n        // 返回操作结果\r\n        return res\r\n    },\r\n    delete(key) {\r\n        const target = this.raw\r\n        const hadKey = target.has(key)\r\n        const res = target.delete(key)\r\n        // 当要删除的元素确实存在时，才触发响应\r\n        if (hadKey) {\r\n            trigger(target, key, 'DELETE')\r\n        }\r\n        return res\r\n    },\r\n    get(key) {\r\n        // 获取原始对象\r\n        const target = this.raw\r\n        // 判断读取的 key 是否存在\r\n        const had = target.has(key)\r\n        // 追踪依赖，建立响应联系\r\n        track(target, key)\r\n        // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，则要返回使用 reactive 包装后的响应式数据\r\n        if (had) {\r\n            const res = target.get(key)\r\n            return typeof res === 'object' ? reactive(res) : res\r\n        }\r\n    },\r\n    set(key, value) {\r\n        const target = this.raw\r\n        const had = target.has(key)\r\n        // 获取旧值\r\n        const oldValue = target.get(key)\r\n        // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value\r\n        const rawValue = value.raw || value\r\n        // 设置新值\r\n        target.set(key, rawValue)\r\n        // 如果不存在，则说明是 ADD 类型的操作，意味着新增\r\n        if (!had) {\r\n            trigger(target, key, 'ADD')\r\n        } else if  (oldValue !== value || (oldValue === oldValue && value === value)) {\r\n            // 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改\r\n            trigger(target, key, 'SET')\r\n        }\r\n    },\r\n    forEach(callback, thisArg) {\r\n        // wrap 函数用来把可代理的值转换为响应式数据\r\n        const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n        // 取得原始数据对象\r\n        const target = this.raw\r\n        // 与 ITERATE_KEY 建立响应联系\r\n        track(target, ITERATE_KEY)\r\n        // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\r\n        target.forEach((v, k) => {\r\n            // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应\r\n           callback.call(thisArg, wrap(v), wrap(k), this)\r\n        })\r\n    },\r\n    // 共用 iterationMethod 方法\r\n    [Symbol.iterator]: iterationMethod,\r\n    entries: iterationMethod,\r\n    values: valuesIterationMethod,\r\n    keys: keysIterationMethod,\r\n }\r\n\r\n // 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应, 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读\r\nfunction createReactive(obj, isShallow = false, isReadonly = false) {\r\n    return new Proxy(obj, {\r\n        // 拦截读取操作，接收第三个参数 receiver\r\n        get: function (target, key, receiver) {\r\n            // 代理对象可以通过 raw 属性访问原始数据\r\n            if (key === 'raw') {\r\n                return target\r\n            }\r\n            if (key === 'size') {\r\n                // 调用 track 函数建立响应联系\r\n                track(target, ITERATE_KEY) \r\n                return Reflect.get(target, key, target)\r\n            }\r\n\r\n            if(isMap(target) || isSet(target)) {\r\n                // 返回定义在 mutableInstrumentations 对象下的方法\r\n                return mutableInstrumentations[key]\r\n            }\r\n\r\n\r\n            // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上,那么返回定义在 arrayInstrumentations 上的值\r\n            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) { \r\n                return Reflect.get(arrayInstrumentations, key, receiver)\r\n            }\r\n\r\n            // 非只读的时候才需要建立响应联系, 如果 key 的类型是 symbol，则不进行追踪\r\n            if (!isReadonly && typeof key !== 'symbol') {\r\n                // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n                track(target, key)\r\n            }\r\n            // 得到原始值结果\r\n            const res = Reflect.get(target, key, receiver)\r\n            // 如果是浅响应，则直接返回原始值\r\n            if (isShallow) {\r\n                return res\r\n            }\r\n            if (typeof res === 'object' && res !== null) {\r\n                // 调用 reactive 将结果包装成响应式数据并返回, 如果数据为只读，则调用 readonly 对值进行包装\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res\r\n        },\r\n        has: function (target, key) { \r\n            // 通过 has 拦截函数实现对 in 操作符的代理\r\n            track(target, key)\r\n            return Reflect.has(target, key)\r\n        },\r\n        ownKeys: function (target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联, 不存在得属性设置新属性值时促发\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        // 拦截设置操作\r\n        set: function (target, key, newVal, receiver) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 先获取旧值\r\n            const oldVal = target[key]\r\n\r\n            // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性\r\n            const type = Array.isArray(target)\r\n            // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度,如果是，则视作 SET 操作，否则是 ADD 操作\r\n            ? Number(key) < target.length ? 'SET' : 'ADD'\r\n            : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\r\n\r\n            // 设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)\r\n            // target === receiver.raw 说明 receiver 就是 target 的代理对象\r\n            if (target === receiver.raw) { \r\n                // 比较新值与旧值，只要当不全等，并且不都是 NaN 的时候才触发响应\r\n                if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) { \r\n                    // 把副作用函数从桶里取出并执行\r\n                    trigger(target, key, type, newVal)\r\n                } \r\n            }\r\n            // 防止'set' on proxy: trap returned falsish for property报错\r\n            return res\r\n        },\r\n        deleteProperty: function(target, key) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 检查被操作的属性是否是对象自己的属性\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target, key)\r\n            // 使用 Reflect.deleteProperty 完成属性的删除\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) { \r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        },\r\n    })\r\n}\r\n\r\nexport function reactive(obj) {\r\n    const existionProxy = reactiveMap.get(obj)\r\n    if (existionProxy) return existionProxy\r\n    // 否则，创建新的代理对象\r\n    const proxy = createReactive(obj)\r\n    // 存储到 Map 中，从而避免重复创建\r\n    reactiveMap.set(obj, proxy)\r\n    return proxy\r\n}\r\n\r\n// 浅只读\r\nexport function shallowReactive(obj) { \r\n    return createReactive(obj, true /* shallow */, true)\r\n}\r\n\r\nexport function readonly(obj) { \r\n    return createReactive(obj, false, true /* 只读 */)\r\n}","import { activeEffect } from './effect'\r\nimport { shouldTrack } from './reactive'\r\nimport { isMap, isSet } from '../util'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 设置对象不存在得属性时\r\nexport const ITERATE_KEY = Symbol()\r\n\r\n// 设置map得key相关得\r\nexport const MAP_KEY_ITERATE_KEY = Symbol()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect或者当禁止追踪时，直接 return \r\n    if (!activeEffect || !shouldTrack) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key, type, newVal) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    // 取得与 key 相关联的副作用函数\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    // 将与 key 相关联的副作用函数添加到 effectsToRun\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    // 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length属性相关联的副作用函数\r\n    if (type === 'ADD' && Array.isArray(target)) { \r\n        // 取出与 length 相关联的副作用函数\r\n        const lengthEffects = depsMap.get('length')\r\n        // 将这些副作用函数添加到 effectsToRun 中，待执行\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    // 对于索引大于或等于新的 length 值的元素， 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行\r\n    if (Array.isArray(target) && key === 'length') { \r\n        depsMap.forEach((effects, key) => {\r\n            if (key >= newVal) {\r\n                effects.forEach(effectFn => {\r\n                    if (effectFn !== activeEffect) {\r\n                        effectsToRun.add(effectFn)\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行\r\n    if (type === 'ADD' || \r\n        type === 'DELETE' ||\r\n        // 如果操作类型是 SET，并且目标对象是 Map 类型的数据，也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行\r\n        (type === 'SET' && isMap(target))\r\n    ) {\r\n        // 取得与 ITERATE_KEY 相关联的副作用函数\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n\r\n        // keys相关\r\n        const iterateEffectKeys = depsMap.get(MAP_KEY_ITERATE_KEY)\r\n        // 将与 MAP_KEY_ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffectKeys && iterateEffectKeys.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","function renderer(domString, container) {\r\n    container.innerHTML = domString\r\n}\r\n\r\nexport default renderer","import flushJob, { jobQueue } from './observer/scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './observer/effect'\r\nimport computed from './observer/computed'\r\nimport { track, trigger, ITERATE_KEY } from './observer/responsive'\r\nimport watch from './observer/watch'\r\nimport { reactive, shallowReactive, readonly } from './observer/reactive'\r\nimport { ref, toRefs, toRef, proxyRefs } from './observer/ref'\r\nimport renderer from './instance/renderer'\r\n\r\n\r\n// const obj = {}\r\n// const proto = { bar: 1 }\r\n// const child = reactive(obj)\r\n// const parent = reactive(proto)\r\n//  // 使用 parent 作为 child 的原型\r\n//  Object.setPrototypeOf(child, parent)\r\n//  effect(() => {\r\n//     console.log(child.bar)\r\n//  })\r\n//   // 修改 child.bar 的值\r\n//   child.bar = 2 // 会导致副作用函数重新执行两次\r\n\r\n// 深响应\r\n// const obj = reactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // 修改 obj.foo.bar 的值，并不能触发响应\r\n// obj.foo.bar = 2\r\n\r\n// 浅响应\r\n// const obj = shallowReactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // obj.foo 是响应的，可以触发副作用函数重新执行\r\n// obj.foo = { bar: 2 }\r\n// // obj.foo.bar 不是响应的，不能触发副作用函数重新执行\r\n// obj.foo.bar = 3\r\n\r\n// 只读\r\n// const obj = readonly({ foo: 1 })\r\n// effect(() => {\r\n//     obj.foo // 可以读取值，但是不需要在副作用函数与数据之间建立响应联系\r\n// })\r\n// // 尝试修改数据，会得到警告\r\n// obj.foo = 2\r\n\r\n// // set\r\n// const p = reactive(new Set([1, 2, 3]))\r\n// // 第一个副作用函数\r\n// effect(() => {\r\n//     console.log(p.size)\r\n// })\r\n// p.add(4)\r\n// p.delete(1)\r\n\r\n// map\r\n// const p = reactive(new Map([['key', 1]]))\r\n// effect(() => {\r\n//     console.log(p.get('key'))\r\n// })\r\n// p.set('key', 2) // 触发响应\r\n\r\n// 迭代器\r\n// const p = reactive(new Map([\r\n//     ['key1', 'value1'],\r\n//     ['key2', 'value2']\r\n// ]))\r\n// effect(() => {\r\n//     for (const [key, value] of p) {\r\n//         console.log(key, value)\r\n//     }\r\n// })\r\n// p.set('key3', 'value3')\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n//  watch(\r\n//     // getter 函数\r\n//     () => obj.foo,\r\n//     // 回调函数\r\n//     async (newValue, oldValue, onInvalidate) => {\r\n//         console.log(newValue, oldValue)\r\n//     },\r\n//     {\r\n//         // 回调函数会在 watch 创建时立即执行一次\r\n//         immediate: true,\r\n//         // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n//         // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n//     }\r\n// )\r\n\r\n\r\n// 原始值\r\n//  const name = ref('vue')\r\n//  effect(() => {\r\n//     console.log(name.value)\r\n//  })\r\n//  // 修改值可以触发响应\r\n//  name.value = 'vue3'\r\n\r\n//  const obj = reactive({ foo: 1, bar: 2 })\r\n//  effect(() => {\r\n//     console.log(proxyRefs({...toRefs(obj)}))\r\n\r\n//  })\r\n//  obj.foo = 2\r\n//  obj.bar = 3 \r\n\r\n\r\nrenderer('<h1>Hello</h1>', document.getElementById('app'))"],"names":["activeEffect","Promise","resolve","toString","Object","prototype","toTypeString","value","call","isMap","val","isSet","reactiveMap","Map","arrayInstrumentations","iterationMethod","wrap","_typeof","reactive","target","this","raw","itr","Symbol","iterator","track","ITERATE_KEY","next","_itr$next","done","valuesIterationMethod","values","_defineProperty","_itr$next2","keysIterationMethod","keys","MAP_KEY_ITERATE_KEY","_itr$next3","forEach","method","originMethod","Array","_len","arguments","length","args","_key","res","apply","_len2","_key2","_mutableInstrumentati","add","key","hadKey","has","trigger","delete","_delete","get","had","set","oldValue","rawValue","callback","thisArg","_this","v","k","mutableInstrumentations","createReactive","obj","isShallow","undefined","isReadonly","Proxy","receiver","Reflect","isArray","hasOwnProperty","readonly","ownKeys","newVal","oldVal","type","console","warn","concat","Number","deleteProperty","existionProxy","proxy","bucket","WeakMap","effectsToRun","iterateEffects","depsMap","effects","Set","effectFn","lengthEffects","iterateEffectKeys","options","scheduler","renderer","domString","container","innerHTML","document","getElementById"],"mappings":"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"}