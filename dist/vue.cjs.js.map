{"version":3,"file":"vue.cjs.js","sources":["../src/observer/effect.js","../src/observer/scheduler.js","../src/util.js","../src/observer/reactive.js","../src/observer/responsive.js","../src/vdom/create-element.js","../src/instance/renderer.js","../src/index.js"],"sourcesContent":["// 用一个全局变量存储被注册的副作用函数\r\nlet activeEffect\r\n// effect 栈\r\nconst effectStack = [] // 新增\r\n\r\n// effect 函数用于注册副作用函数\r\nfunction effect(fn, options = {}) {\r\n    const effectFn = () => {\r\n        // 调用 cleanup 函数完成清除工作\r\n        cleanup(effectFn)\r\n        // 当 effectFn 执行时，将其设置为当前激活的副作用函数\r\n        activeEffect = effectFn\r\n        // 在调用副作用函数之前将当前副作用函数压入栈中\r\n        effectStack.push(effectFn)\r\n        // 将 fn 的执行结果存储到 res 中\r\n        const res = fn()\r\n        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值\r\n        effectStack.pop()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n        // 将 res 作为 effectFn 的返回值\r\n        return res\r\n    }\r\n    // 将 options 挂载到 effectFn 上\r\n    effectFn.options = options\r\n    // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合\r\n    effectFn.deps = []\r\n    // 只有非 lazy 的时候，才执行\r\n    if (!options.lazy) {\r\n        // 执行副作用函数\r\n        effectFn()\r\n    }\r\n    // 将副作用函数作为返回值返回\r\n    return effectFn\r\n}\r\n\r\n// 副作用执行时先清除之前的副作用 \r\nfunction cleanup(effectFn) {\r\n    // 遍历 effectFn.deps 数组\r\n    for (let i = 0; i < effectFn.deps.length; i++) {\r\n        // deps 是依赖集合\r\n        const deps = effectFn.deps[i]\r\n        // 将 effectFn 从依赖集合中移除\r\n        deps.delete(effectFn)\r\n    }\r\n    // 最后需要重置 effectFn.deps 数组\r\n    effectFn.deps.length = 0\r\n}\r\n\r\nexport {\r\n    activeEffect,\r\n    cleanup,\r\n}\r\n\r\nexport default effect","// 定义一个任务队列\r\nexport const jobQueue = new Set()\r\n\r\n// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列\r\nconst p = Promise.resolve()\r\n\r\n// 一个标志代表是否正在刷新队列\r\nlet isFlushing = false\r\nfunction flushJob() {\r\n    // 如果队列正在刷新，则什么都不做\r\n    if (isFlushing) return\r\n    // 设置为 true，代表正在刷新\r\n    isFlushing = true\r\n    // 在微任务队列中刷新 jobQueue 队列\r\n    p.then(() => {\r\n        jobQueue.forEach(job => job())\r\n    }).finally(() => {\r\n        // 结束后重置 isFlushing\r\n        isFlushing = false\r\n    })\r\n}\r\n\r\nexport default flushJob","const toString = Object.prototype.toString\r\n\r\nexport const toTypeString = (value) => toString.call(value)\r\n\r\n// 判断map类型\r\nexport const isMap = (val) => toTypeString(val) === '[object Map]'\r\n// 判断set类型\r\nexport const isSet = (val) => toTypeString(val) === '[object Set]'","import { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './responsive'\r\nimport { isMap, isSet } from '../util'\r\n\r\nconst TriggerType = { \r\n    SET: 'SET',\r\n    ADD: 'ADD'\r\n }\r\n // 定义一个 Map 实例，存储原始对象到代理对象的映射\r\nconst reactiveMap = new Map()\r\n\r\nconst arrayInstrumentations = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {\r\n    const originMethod = Array.prototype[method]\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\r\n        let res = originMethod.apply(this, args)\r\n        if (res === false || res === -1) {\r\n            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值\r\n            res = originMethod.apply(this.raw, args)\r\n        }\r\n        // 返回最终结果\r\n        return res\r\n    }\r\n})\r\n\r\n // 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪\r\n export let shouldTrack = true\r\n  // 重写数组的 push、pop、shift、unshift 以及 splice 方法\r\n ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {\r\n    // 取得原始 push 方法\r\n    const originMethod = Array.prototype[method]\r\n    // 重写\r\n    arrayInstrumentations[method] = function(...args) {\r\n        // 在调用原始方法之前，禁止追踪\r\n        shouldTrack = false\r\n        // push 方法的默认行为\r\n        let res = originMethod.apply(this, args)\r\n        // 在调用原始方法之后，恢复原来的行为，即允许追踪\r\n        shouldTrack = true\r\n        return res\r\n    }\r\n })\r\n\r\n // 抽离为独立的函数，便于复用\r\n function iterationMethod() {\r\n    const target = this.raw\r\n    const itr = target[Symbol.iterator]()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val): val\r\n    track(target, ITERATE_KEY)\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                value:  value ? [wrap(value[0]), wrap(value[1])] : value,\r\n                done,\r\n            }\r\n        }\r\n    }\r\n }\r\n\r\n function valuesIterationMethod() {\r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 通过 target.values 获取原始迭代器方法\r\n    const itr = target.values()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    track(target, ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n function keysIterationMethod() { \r\n    // 获取原始数据对象 target\r\n    const target = this.raw\r\n    // 获取原始迭代器方法\r\n    const itr = target.keys()\r\n    const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系\r\n    track(target, MAP_KEY_ITERATE_KEY)\r\n    // 将其返回\r\n    return {\r\n        next() {\r\n            const { value, done } = itr.next()\r\n            return {\r\n                // value 是值，而非键值对，所以只需要包裹 value 即可\r\n                value: wrap(value),\r\n                done\r\n            }\r\n        },\r\n        [Symbol.iterator]() {\r\n            return this\r\n        }\r\n    }\r\n }\r\n\r\n // 定义一个对象，将自定义的 add 方法定义到该对象下\r\n const mutableInstrumentations = {\r\n    add(key) {\r\n        // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象\r\n        const target = this.raw\r\n        // 先判断值是否已经存在\r\n        const hadKey = target.has(key)\r\n        // 通过原始数据对象执行 add 方法添加具体的值，注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的\r\n        const res = target.add(key) \r\n        // 调用 trigger 函数触发响应，并指定操作类型为 ADD\r\n        if(!hadKey) {\r\n            trigger(target, key, 'ADD')\r\n        }\r\n        // 返回操作结果\r\n        return res\r\n    },\r\n    delete(key) {\r\n        const target = this.raw\r\n        const hadKey = target.has(key)\r\n        const res = target.delete(key)\r\n        // 当要删除的元素确实存在时，才触发响应\r\n        if (hadKey) {\r\n            trigger(target, key, 'DELETE')\r\n        }\r\n        return res\r\n    },\r\n    get(key) {\r\n        // 获取原始对象\r\n        const target = this.raw\r\n        // 判断读取的 key 是否存在\r\n        const had = target.has(key)\r\n        // 追踪依赖，建立响应联系\r\n        track(target, key)\r\n        // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，则要返回使用 reactive 包装后的响应式数据\r\n        if (had) {\r\n            const res = target.get(key)\r\n            return typeof res === 'object' ? reactive(res) : res\r\n        }\r\n    },\r\n    set(key, value) {\r\n        const target = this.raw\r\n        const had = target.has(key)\r\n        // 获取旧值\r\n        const oldValue = target.get(key)\r\n        // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value\r\n        const rawValue = value.raw || value\r\n        // 设置新值\r\n        target.set(key, rawValue)\r\n        // 如果不存在，则说明是 ADD 类型的操作，意味着新增\r\n        if (!had) {\r\n            trigger(target, key, 'ADD')\r\n        } else if  (oldValue !== value || (oldValue === oldValue && value === value)) {\r\n            // 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改\r\n            trigger(target, key, 'SET')\r\n        }\r\n    },\r\n    forEach(callback, thisArg) {\r\n        // wrap 函数用来把可代理的值转换为响应式数据\r\n        const wrap = (val) => typeof val === 'object' ? reactive(val) : val\r\n        // 取得原始数据对象\r\n        const target = this.raw\r\n        // 与 ITERATE_KEY 建立响应联系\r\n        track(target, ITERATE_KEY)\r\n        // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\r\n        target.forEach((v, k) => {\r\n            // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应\r\n           callback.call(thisArg, wrap(v), wrap(k), this)\r\n        })\r\n    },\r\n    // 共用 iterationMethod 方法\r\n    [Symbol.iterator]: iterationMethod,\r\n    entries: iterationMethod,\r\n    values: valuesIterationMethod,\r\n    keys: keysIterationMethod,\r\n }\r\n\r\n // 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应, 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读\r\nfunction createReactive(obj, isShallow = false, isReadonly = false) {\r\n    return new Proxy(obj, {\r\n        // 拦截读取操作，接收第三个参数 receiver\r\n        get: function (target, key, receiver) {\r\n            // 代理对象可以通过 raw 属性访问原始数据\r\n            if (key === 'raw') {\r\n                return target\r\n            }\r\n            if (key === 'size') {\r\n                // 调用 track 函数建立响应联系\r\n                track(target, ITERATE_KEY) \r\n                return Reflect.get(target, key, target)\r\n            }\r\n\r\n            if(isMap(target) || isSet(target)) {\r\n                // 返回定义在 mutableInstrumentations 对象下的方法\r\n                return mutableInstrumentations[key]\r\n            }\r\n\r\n\r\n            // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上,那么返回定义在 arrayInstrumentations 上的值\r\n            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) { \r\n                return Reflect.get(arrayInstrumentations, key, receiver)\r\n            }\r\n\r\n            // 非只读的时候才需要建立响应联系, 如果 key 的类型是 symbol，则不进行追踪\r\n            if (!isReadonly && typeof key !== 'symbol') {\r\n                // 将副作用函数 activeEffect 添加到存储副作用函数的桶中\r\n                track(target, key)\r\n            }\r\n            // 得到原始值结果\r\n            const res = Reflect.get(target, key, receiver)\r\n            // 如果是浅响应，则直接返回原始值\r\n            if (isShallow) {\r\n                return res\r\n            }\r\n            if (typeof res === 'object' && res !== null) {\r\n                // 调用 reactive 将结果包装成响应式数据并返回, 如果数据为只读，则调用 readonly 对值进行包装\r\n                return isReadonly ? readonly(res) : reactive(res)\r\n            }\r\n            return res\r\n        },\r\n        has: function (target, key) { \r\n            // 通过 has 拦截函数实现对 in 操作符的代理\r\n            track(target, key)\r\n            return Reflect.has(target, key)\r\n        },\r\n        ownKeys: function (target) {\r\n            // 将副作用函数与 ITERATE_KEY 关联, 不存在得属性设置新属性值时促发\r\n            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\r\n            return Reflect.ownKeys(target)\r\n        },\r\n        // 拦截设置操作\r\n        set: function (target, key, newVal, receiver) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 先获取旧值\r\n            const oldVal = target[key]\r\n\r\n            // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性\r\n            const type = Array.isArray(target)\r\n            // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度,如果是，则视作 SET 操作，否则是 ADD 操作\r\n            ? Number(key) < target.length ? 'SET' : 'ADD'\r\n            : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\r\n\r\n            // 设置属性值\r\n            const res = Reflect.set(target, key, newVal, receiver)\r\n            // target === receiver.raw 说明 receiver 就是 target 的代理对象\r\n            if (target === receiver.raw) { \r\n                // 比较新值与旧值，只要当不全等，并且不都是 NaN 的时候才触发响应\r\n                if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) { \r\n                    // 把副作用函数从桶里取出并执行\r\n                    trigger(target, key, type, newVal)\r\n                } \r\n            }\r\n            // 防止'set' on proxy: trap returned falsish for property报错\r\n            return res\r\n        },\r\n        deleteProperty: function(target, key) {\r\n            // 如果是只读的，则打印警告信息并返回\r\n            if (isReadonly) { \r\n                console.warn(`属性 ${key} 是只读的`)\r\n                return true\r\n            }\r\n            // 检查被操作的属性是否是对象自己的属性\r\n            const hadKey = Object.prototype.hasOwnProperty.call(target, key)\r\n            // 使用 Reflect.deleteProperty 完成属性的删除\r\n            const res = Reflect.deleteProperty(target, key)\r\n            if (res && hadKey) { \r\n                // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新\r\n                trigger(target, key, 'DELETE')\r\n            }\r\n            return res\r\n        },\r\n    })\r\n}\r\n\r\nexport function reactive(obj) {\r\n    const existionProxy = reactiveMap.get(obj)\r\n    if (existionProxy) return existionProxy\r\n    // 否则，创建新的代理对象\r\n    const proxy = createReactive(obj)\r\n    // 存储到 Map 中，从而避免重复创建\r\n    reactiveMap.set(obj, proxy)\r\n    return proxy\r\n}\r\n\r\n// 浅只读\r\nexport function shallowReactive(obj) { \r\n    return createReactive(obj, true /* shallow */, true)\r\n}\r\n\r\nexport function readonly(obj) { \r\n    return createReactive(obj, false, true /* 只读 */)\r\n}","import { activeEffect } from './effect'\r\nimport { shouldTrack } from './reactive'\r\nimport { isMap, isSet } from '../util'\r\n\r\n// 储存副作用桶\r\nconst bucket = new WeakMap()\r\n\r\n// 设置对象不存在得属性时\r\nexport const ITERATE_KEY = Symbol()\r\n\r\n// 设置map得key相关得\r\nexport const MAP_KEY_ITERATE_KEY = Symbol()\r\n\r\n// 在 get 拦截函数内调用 track 函数追踪变化 \r\nexport function track(target, key) {\r\n    // 没有 activeEffect或者当禁止追踪时，直接 return \r\n    if (!activeEffect || !shouldTrack) return target[key]\r\n    // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key -->effects\r\n    let depsMap = bucket.get(target)\r\n    // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联\r\n    if (!depsMap) {\r\n        bucket.set(target, (depsMap = new Map()))\r\n    }\r\n    // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，里面存储着所有与当前 key 相关联的副作用函数：effects\r\n    let deps = depsMap.get(key)\r\n    // 如果 deps 不存在，同样新建一个 Set 并与 key 关联\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()))\r\n    }\r\n    // 最后将当前激活的副作用函数添加到“桶”里\r\n    deps.add(activeEffect)\r\n    // deps 就是一个与当前副作用函数存在联系的依赖集合\r\n    // 将其添加到 activeEffect.deps 数组中\r\n    activeEffect.deps.push(deps) // 新增\r\n}\r\n\r\n\r\n\r\n// 在 set 拦截函数内调用 trigger 函数触发变化\r\nexport function trigger(target, key, type, newVal) {\r\n    const depsMap = bucket.get(target)\r\n    if (!depsMap) return\r\n    // 取得与 key 相关联的副作用函数\r\n    const effects = depsMap.get(key)\r\n    const effectsToRun = new Set()\r\n    // 将与 key 相关联的副作用函数添加到 effectsToRun\r\n    effects && effects.forEach(effectFn => {\r\n        // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行\r\n        if (effectFn !== activeEffect) {\r\n            effectsToRun.add(effectFn)\r\n        }\r\n    })\r\n    // 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length属性相关联的副作用函数\r\n    if (type === 'ADD' && Array.isArray(target)) { \r\n        // 取出与 length 相关联的副作用函数\r\n        const lengthEffects = depsMap.get('length')\r\n        // 将这些副作用函数添加到 effectsToRun 中，待执行\r\n        lengthEffects && lengthEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n    // 对于索引大于或等于新的 length 值的元素， 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行\r\n    if (Array.isArray(target) && key === 'length') { \r\n        depsMap.forEach((effects, key) => {\r\n            if (key >= newVal) {\r\n                effects.forEach(effectFn => {\r\n                    if (effectFn !== activeEffect) {\r\n                        effectsToRun.add(effectFn)\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行\r\n    if (type === 'ADD' || \r\n        type === 'DELETE' ||\r\n        // 如果操作类型是 SET，并且目标对象是 Map 类型的数据，也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行\r\n        (type === 'SET' && isMap(target))\r\n    ) {\r\n        // 取得与 ITERATE_KEY 相关联的副作用函数\r\n        const iterateEffects = depsMap.get(ITERATE_KEY)\r\n        // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffects && iterateEffects.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n\r\n        // keys相关\r\n        const iterateEffectKeys = depsMap.get(MAP_KEY_ITERATE_KEY)\r\n        // 将与 MAP_KEY_ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun\r\n        iterateEffectKeys && iterateEffectKeys.forEach(effectFn => {\r\n            if (effectFn !== activeEffect) {\r\n                effectsToRun.add(effectFn)\r\n            }\r\n        })\r\n    }\r\n\r\n    effectsToRun.forEach(effectFn => {\r\n        if (effectFn.options.scheduler) {\r\n            effectFn.options.scheduler(effectFn)\r\n        } else {\r\n            effectFn()\r\n        }\r\n    })\r\n}","// 文本节点的 type 标识\r\nexport const Text = Symbol()\r\n\r\n// 注释节点的 type 标识\r\nexport const Comment = Symbol()\r\n\r\nexport const Fragment = Symbol()\r\n\r\n// 用于创建元素\r\nexport function createElement(tag){\r\n    return document.createElement(tag)\r\n}\r\n// 用于设置元素的文本节点\r\nexport function setElementText(el, text) {\r\n    el.textContent = text\r\n}\r\n// 用于在给定的 parent 下添加指定元素\r\nexport function insert(el, parent, anchor = null) {\r\n    if(parent.type === 'root') {\r\n        parent = document.getElementById('app')\r\n    }\r\n    parent.insertBefore(el, anchor)\r\n}\r\n\r\n// 创建文本节点\r\nexport function createText(text) {\r\n    return document.createTextNode(text)\r\n}\r\n\r\n// 设置文本节点\r\nexport function setText(el, text) {\r\n    el.nodeValue = text\r\n}\r\n\r\n// 创建注释节点\r\nexport function createComment(text) {\r\n    return document.createComment(text)\r\n}\r\n\r\n// 特殊处理props\r\nfunction shouldSetAsProps(el, key, value) {\r\n    if (key === 'form' && el.tagName === 'INPUT') return false\r\n    return key in el\r\n}\r\n\r\n// 将属性设置相关操作封装到 patchProps 函数中，并作为渲染器选项传递\r\nexport function patchProps(el, key, prevValue, nextValue) {\r\n    // 匹配以 on 开头的属性，视其为事件\r\n    if (/^on/.test(key)) {\r\n        // 定义 el._vei 为一个对象，存在事件名称到事件处理函数的映射\r\n        let invokers = el._vei || (el._vei = {})\r\n        //根据事件名称获取 invoker\r\n        let invoker = invokers[key]\r\n        // 根据属性名称得到对应的事件名称，例如 onClick ---> click\r\n        const name = key.slice(2).toLowerCase()\r\n        if (nextValue) {\r\n            if (!invoker) {\r\n                // 如果没有 invoker，则将一个伪造的 invoker 缓存到 el._vei 中vei 是 vue event invoker 的首字母缩写\r\n                invoker = el._vei[key] = (e) => {\r\n                    // e.timeStamp 是事件发生的时间, 如果事件发生的时间早于事件处理函数绑定的时间，则不执行事件处理函数\r\n                    if (e.timeStamp < invoker.attached) return\r\n                    // 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数\r\n                    if (Array.isArray(invoker.value)) {\r\n                        invoker.value.forEach(fn => fn(e))\r\n                    } else {\r\n                        // 否则直接作为函数调用\r\n                        invoker.value(e)\r\n                    }\r\n                }\r\n                // 将真正的事件处理函数赋值给 invoker.val\r\n                invoker.value = nextValue\r\n                // 添加 invoker.attached 属性，存储事件处理函数被绑定的时间\r\n                invoker.attached = performance.now()\r\n                // 绑定 invoker 作为事件处理函数\r\n                el.addEventListener(name, invoker)\r\n            } else {\r\n                // 如果 invoker 存在，意味着更新，并且只需要更新 invoker.value的值即可\r\n                invoker.value = nextValue\r\n            }\r\n        } else if(invoker) {\r\n            // 新的事件绑定函数不存在，且之前绑定的 invoker 存在，则移除绑定\r\n            el.removeEventListener(name, invoker)\r\n        }\r\n        // 绑定事件，nextValue 为事件处理函数\r\n        el.addEventListener(name, nextValue)\r\n    }\r\n    else if (key === 'class') { // 对 class 进行特殊处理\r\n        el.className = nextValue || ''\r\n    } else if (shouldSetAsProps(el, key, nextValue)) {  // 使用 shouldSetAsProps 函数判断是否应该作为 DOM Properties设置\r\n        // 获取该 DOM Properties 的类型\r\n        const type = typeof el[key]\r\n        // 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true\r\n        if (type === 'boolean' && nextValue === '') {\r\n            el[key] = true\r\n        } else {\r\n            el[key] = nextValue\r\n        }\r\n    } else {\r\n        // 如果要设置的属性没有对应的 DOM Properties，则使用setAttribute 函数设置属性\r\n        el.setAttribute(key, nextValue)\r\n    }\r\n}","import { \r\n    Text, \r\n    Comment,\r\n    Fragment,\r\n} from '../vdom/create-element'\r\n\r\n\r\nfunction createRenderer(options) {\r\n    // 通过 options 得到操作 DOM 的 API\r\n    const {\r\n        createElement, \r\n        setElementText, \r\n        insert,\r\n        patchProps,\r\n        createText,\r\n        setText,\r\n        createComment,\r\n    } = options\r\n\r\n    // 卸载操作\r\n    function unmount(vnode) {\r\n        // 在卸载时，如果卸载的 vnode 类型为 Fragment，则需要卸载其 children\r\n        if (vnode.type === Fragment) {\r\n            vnode.children.forEach(c => unmount(c))\r\n            return\r\n        }\r\n        // 获取 el 的父元素\r\n        const parent = vnode.el.parentNode\r\n        // 调用 removeChild 移除元素\r\n        if (parent) parent.removeChild(vnode.el)\r\n    }\r\n\r\n    // 在这个作用域内定义的函数都可以访问那些 API\r\n    function mountElement(vnode, container) {\r\n        // 让 vnode.el 引用真实 DOM 元素\r\n        const el = vnode.el = createElement(vnode.type)\r\n        // 处理子节点，如果子节点是字符串，代表元素具有文本节点\r\n        if (typeof vnode.children === 'string') {\r\n            // 因此只需要设置元素的 textContent 属性即可\r\n            setElementText(el, vnode.children)\r\n        } else if(Array.isArray(vnode.children)) {\r\n            // 如果 children 是数组，则遍历每一个子节点，并调用 patch 函数挂载它们\r\n            vnode.children.forEach(child => {\r\n                patch(null, child, el)\r\n            })\r\n        }\r\n        // 如果 vnode.props 存在才处理它\r\n        if (vnode.props) {\r\n            // 遍历 vnode.props\r\n            for (const key in vnode.props) {\r\n                // 调用 patchProps 函数即可\r\n                patchProps(el, key, null, vnode.props[key])\r\n            }\r\n        }\r\n        // 调用 insert 函数将元素插入到容器内\r\n        insert(el, container)\r\n    }\r\n\r\n    // 更新子节点\r\n    function patchChildren(n1, n2, container) {\r\n        // 判断新子节点的类型是否是文本节点\r\n        if (typeof n2.children === 'string'){\r\n            // 旧子节点的类型有三种可能：没有子节点、文本子节点以及一组子节点, 只有当旧子节点为一组子节点时，才需要逐个卸载，其他情况下什么都不需要\r\n            if (Array.isArray(n1.children)) {\r\n                n1.children.forEach((c) => unmount(c))\r\n            }\r\n            // 最后将新的文本节点内容设置给容器元素\r\n            setElementText(container, n2.children)\r\n        }  else if (Array.isArray(n2.children)) {\r\n            // 说明新子节点是一组子节点, 判断旧子节点是否也是一组子节点\r\n            if (Array.isArray(n1.children)) {\r\n                // 代码运行到这里，则说明新旧子节点都是一组子节点，这里涉及核心的Diff 算法\r\n                const oldChildren = n1.children\r\n                const newChildren = n2.children\r\n\r\n                // 遍历新的 children\r\n                for (let i = 0; i < newChildren.length; i++) {\r\n                    const newVNode = newChildren[i]\r\n                    // 遍历旧的 children\r\n                    for (let j = 0; j < oldChildren.length; j++) {\r\n                        const oldVNode = oldChildren[j]\r\n                        // 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新\r\n                        if (newVNode.key === oldVNode.key) {\r\n                            patch(oldVNode, newVNode, container)\r\n                            break // 这里需要 break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // // 旧的一组子节点的长度\r\n                // const oldLen = oldChildren.length\r\n                // // 新的一组子节点的长度\r\n                // const newLen = newChildren.length\r\n                // // 两组子节点的公共长度，即两者中较短的那一组子节点的长度\r\n                // const commonLength = Math.min(oldLen, newLen)\r\n                // // 遍历 commonLength 次\r\n                // for (let i = 0; i < commonLength.length; i++) {\r\n                //     // 调用 patch 函数逐个更新子节点\r\n                //     patch(oldChildren[i], newChildren[i], container)\r\n                // }\r\n                // // 如果 newLen > oldLen，说明有新子节点需要挂载\r\n                // if (newLen > oldLen) {\r\n                //     for (let i = commonLength; i < newLen; i++) {\r\n                //         patch(null, newChildren[i], container)\r\n                //     }\r\n                // } else if (oldLen > newLen) {\r\n                //     // 如果 oldLen > newLen，说明有旧子节点需要卸载\r\n                //     for (let i = commonLength; i < oldLen; i++) {\r\n                //         unmount(oldChildren[i])\r\n                //     }\r\n                // }\r\n            } else {\r\n                // 此时：旧子节点要么是文本子节点，要么不存在,但无论哪种情况，我们都只需要将容器清空，然后将新的一组子节点逐个挂载\r\n                setElementText(container, '')\r\n                n2.children.forEach(c => patch(null, c, container))\r\n            }\r\n        } else {\r\n            // 代码运行到这里，说明新子节点不存在, 旧子节点是一组子节点，只需逐个卸载即可\r\n            if (Array.isArray(n1.children)) {\r\n                n1.children.forEach(c => unmount(c))\r\n            } else if (typeof n1.children === 'string') {\r\n                // 旧子节点是文本子节点，清空内容即可\r\n                setElementText(container, '')\r\n            }\r\n        }\r\n    }\r\n\r\n    // 更新\r\n    function patchElement(n1, n2) {\r\n        const el = n2.el = n1.el\r\n        const oldProps = n1.props\r\n        const newProps = n2.props\r\n        // 第一步：更新 props\r\n        for (const key in newProps) {\r\n            if (newProps[key] !== oldProps[key]) {\r\n                patchProps(el, key, oldProps[key], newProps[key])\r\n            }\r\n        }\r\n        for (const key in oldProps) {\r\n            if (!(key in newProps)) {\r\n                patchProps(el, key, oldProps[key], null)\r\n            }\r\n        }\r\n        // 第二步：更新 children\r\n        patchChildren(n1, n2, el)\r\n    }\r\n\r\n\r\n    // n1：旧 vnode, n2：新 vnode, container：容器\r\n    function patch(n1, n2, container) {\r\n        // 如果 n1 存在，则对比 n1 和 n2 的类型\r\n        if (n1 && n1.type !== n2.type) {\r\n            // 如果新旧 vnode 的类型不同，则直接将旧 vnode 卸载\r\n            unmount(n1)\r\n            n1 = null\r\n        }\r\n        // 代码运行到这里，证明 n1 和 n2 所描述的内容相同\r\n        const { type } = n2\r\n        // 如果 n2.type 的值是字符串类型，则它描述的是普通标签元素\r\n        if (typeof type === 'string') {\r\n             // 如果 n1 不存在，意味着挂载，则调用 mountElement 函数完成挂载\r\n            if (!n1) {\r\n                mountElement(n2, container)\r\n            } else {\r\n                // n1 存在，意味着打补丁\r\n                patchElement(n1, n2)\r\n            }\r\n        } else if (type === Text) {\r\n            // 如果新 vnode 的类型是 Text，则说明该 vnode 描述的是文本节点,如果没有旧节点，则进行挂载\r\n            if (!n1) {\r\n                // 使用 createTextNode 创建文本节点\r\n                const el = n2.el = createText(n2.children)\r\n                // 将文本节点插入到容器中\r\n                insert(el, container)\r\n            } else {\r\n                // 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即可\r\n                const el = n2.el = n1.el\r\n                if (n2.children !== n1.children) {\r\n                    setText(el, n2.children)\r\n                }\r\n            }\r\n        } else if (type === Comment) {\r\n            // 如果新 vnode 的类型是 Text，则说明该 vnode 描述的是文本节点,如果没有旧节点，则进行挂载\r\n            if (!n1) {\r\n                // 使用 createTextNode 创建文本节点\r\n                const el = n2.el = createComment(n2.children)\r\n                // 将文本节点插入到容器中\r\n                insert(el, container)\r\n            } else {\r\n                // 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即可\r\n                const el = n2.el = n1.el\r\n                if (n2.children !== n1.children) {\r\n                    setText(el, n2.children)\r\n                }\r\n            }\r\n        } else if (type === Fragment) {\r\n            if (!n1) {\r\n                // 如果旧 vnode 不存在，则只需要将 Fragment 的 children 逐个挂载即可\r\n                n2.children.forEach(c => patch(null, c, container))\r\n            } else {\r\n                // 如果旧 vnode 存在，则只需要更新 Fragment 的 children 即可\r\n                patchChildren(n1, n2, container)\r\n            }\r\n        } else if(typeof type === 'object') {\r\n            // 如果 n2.type 的值的类型是对象，则它描述的是组件\r\n        }\r\n       \r\n    }\r\n\r\n    function render(vnode, container) {\r\n        if (vnode) {\r\n            // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数，进行打补\r\n            patch(container._vnode, vnode, container)\r\n        } else {\r\n            if (container._vnode) {\r\n                // 调用 unmount 函数卸载 vnode\r\n                unmount(container._vnode)\r\n            }\r\n        }\r\n        // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\r\n        container._vnode = vnode\r\n    }\r\n\r\n    function hydrate(vnode, container) {\r\n\r\n    }\r\n\r\n    return {\r\n        render,\r\n        hydrate,\r\n    }\r\n}\r\n\r\nexport default createRenderer","import flushJob, { jobQueue } from './observer/scheduler' // 调度执行\r\nimport effect, { activeEffect, cleanup } from './observer/effect'\r\nimport computed from './observer/computed'\r\nimport { track, trigger, ITERATE_KEY } from './observer/responsive'\r\nimport watch from './observer/watch'\r\nimport { reactive, shallowReactive, readonly } from './observer/reactive'\r\nimport { ref, toRefs, toRef, proxyRefs } from './observer/ref'\r\nimport createRenderer from './instance/renderer'\r\nimport { \r\n    createElement, \r\n    setElementText, \r\n    insert, \r\n    patchProps, \r\n    createText, \r\n    setText, \r\n    Text, \r\n    Comment,\r\n    createComment,\r\n    Fragment,\r\n} from './vdom/create-element'\r\n\r\nconst renderer = createRenderer({\r\n    createElement, setElementText, insert, patchProps, createText, setText, createComment\r\n})\r\n\r\n// const obj = {}\r\n// const proto = { bar: 1 }\r\n// const child = reactive(obj)\r\n// const parent = reactive(proto)\r\n//  // 使用 parent 作为 child 的原型\r\n//  Object.setPrototypeOf(child, parent)\r\n//  effect(() => {\r\n//     console.log(child.bar)\r\n//  })\r\n//   // 修改 child.bar 的值\r\n//   child.bar = 2 // 会导致副作用函数重新执行两次\r\n\r\n// 深响应\r\n// const obj = reactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // 修改 obj.foo.bar 的值，并不能触发响应\r\n// obj.foo.bar = 2\r\n\r\n// 浅响应\r\n// const obj = shallowReactive({ foo: { bar: 1 } })\r\n// effect(() => {\r\n//     console.log(obj.foo.bar)\r\n// })\r\n// // obj.foo 是响应的，可以触发副作用函数重新执行\r\n// obj.foo = { bar: 2 }\r\n// // obj.foo.bar 不是响应的，不能触发副作用函数重新执行\r\n// obj.foo.bar = 3\r\n\r\n// 只读\r\n// const obj = readonly({ foo: 1 })\r\n// effect(() => {\r\n//     obj.foo // 可以读取值，但是不需要在副作用函数与数据之间建立响应联系\r\n// })\r\n// // 尝试修改数据，会得到警告\r\n// obj.foo = 2\r\n\r\n// // set\r\n// const p = reactive(new Set([1, 2, 3]))\r\n// // 第一个副作用函数\r\n// effect(() => {\r\n//     console.log(p.size)\r\n// })\r\n// p.add(4)\r\n// p.delete(1)\r\n\r\n// map\r\n// const p = reactive(new Map([['key', 1]]))\r\n// effect(() => {\r\n//     console.log(p.get('key'))\r\n// })\r\n// p.set('key', 2) // 触发响应\r\n\r\n// 迭代器\r\n// const p = reactive(new Map([\r\n//     ['key1', 'value1'],\r\n//     ['key2', 'value2']\r\n// ]))\r\n// effect(() => {\r\n//     for (const [key, value] of p) {\r\n//         console.log(key, value)\r\n//     }\r\n// })\r\n// p.set('key3', 'value3')\r\n\r\n// 返回需要立即执行得函数\r\n// const effectFn = effect(\r\n//     // getter 返回 obj.foo 与 obj.bar 的和\r\n//     () => obj.foo + obj.bar,\r\n//     // options\r\n//     {\r\n//         // 调度器 scheduler 是一个函数\r\n//         scheduler(fn) {\r\n//             // 每次调度时，将副作用函数添加到 jobQueue 队列中\r\n//             jobQueue.add(fn)\r\n//             // 调用 flushJob 刷新队列\r\n//             flushJob()\r\n//         },\r\n//         lazy: true, // 不会立即执行当前函数\r\n//     }\r\n// )\r\n\r\n// 计算属性案列\r\n// const sumRes = computed(() => obj.foo + obj.bar)\r\n// // effect嵌套\r\n// effect(function effectFn() {\r\n//     console.log(sumRes.value)\r\n// })\r\n//  // 修改 obj.foo\r\n//  obj.foo++\r\n\r\n // watch\r\n//  watch(\r\n//     // getter 函数\r\n//     () => obj.foo,\r\n//     // 回调函数\r\n//     async (newValue, oldValue, onInvalidate) => {\r\n//         console.log(newValue, oldValue)\r\n//     },\r\n//     {\r\n//         // 回调函数会在 watch 创建时立即执行一次\r\n//         immediate: true,\r\n//         // 回调函数会在 watch 创建时立即执行一次, 当 flush 的值为 'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中\r\n//         // flush: 'pre' // 还可以指定为 'post' | 'sync'\r\n//     }\r\n// )\r\n\r\n\r\n// 原始值\r\n//  const name = ref('vue')\r\n//  effect(() => {\r\n//     console.log(name.value)\r\n//  })\r\n//  // 修改值可以触发响应\r\n//  name.value = 'vue3'\r\n\r\n//  const obj = reactive({ foo: 1, bar: 2 })\r\n//  effect(() => {\r\n//     console.log(proxyRefs({...toRefs(obj)}))\r\n\r\n//  })\r\n//  obj.foo = 2\r\n//  obj.bar = 3 \r\n\r\n// const vnode = {\r\n//     type: 'h1',\r\n//     // 使用 props 描述一个元素的属性\r\n//     props: {\r\n//         id: 'foo',\r\n//         // 使用 onXxx 描述事件\r\n//        onClick: [\r\n//             // 第一个事件处理函数\r\n//             () => {\r\n//                 alert('clicked 1')\r\n//             },\r\n//             // 第二个事件处理函数\r\n//             () => {\r\n//                 alert('clicked 2')\r\n//             }\r\n//         ],\r\n//         onContextmenu: () => {\r\n//             alert('contextmenu')\r\n//         }\r\n//     },\r\n//     children: [{\r\n//         type: 'p',\r\n//         children: 'hello' \r\n//     }, {\r\n//         // 描述文本节点\r\n//         type: Text,\r\n//         children: '我是文本内容'\r\n//     }, {\r\n//         // 描述注释节点\r\n//         type: Comment,\r\n//         children: '我是注释内容'\r\n//     }, {\r\n//         type: 'ul',\r\n//         children: [{\r\n//             type: Fragment,\r\n//             children: [\r\n//                 { type: 'li', children: 'text 1', key: 1 },\r\n//                 { type: 'li', children: 'text 2', key: 2 },\r\n//                 { type: 'li', children: 'text 3', key: 3 }\r\n//             ]\r\n//         }]\r\n//     }]\r\n// }\r\n// effect(() => {\r\n//     renderer.render(vnode, document.querySelector('#app'))\r\n// }) \r\n\r\nconst oldVNode = {\r\n    type: 'div',\r\n    children: [\r\n        { type: 'p', children: '1', key: 1 },\r\n        { type: 'p', children: '2', key: 2 },\r\n        { type: 'p', children: 'hello', key: 3 }\r\n    ]\r\n}\r\n\r\nconst newVNode = {\r\n    type: 'div',\r\n    children: [\r\n        { type: 'p', children: 'world', key: 3 },\r\n        { type: 'p', children: '1', key: 1 },\r\n        { type: 'p', children: '2', key: 2 },\r\n    ]\r\n}\r\n\r\n // 首次挂载\r\n renderer.render(oldVNode, document.querySelector('#app'))\r\n setTimeout(() => {\r\n    // 1 秒钟后更新\r\n    renderer.render(newVNode, document.querySelector('#app'))\r\n }, 1000)"],"names":["activeEffect","Promise","resolve","toString","Object","prototype","toTypeString","value","call","isMap","val","isSet","reactiveMap","Map","arrayInstrumentations","iterationMethod","wrap","_typeof","reactive","target","this","raw","itr","Symbol","iterator","track","ITERATE_KEY","next","_itr$next","done","valuesIterationMethod","values","_defineProperty","_itr$next2","keysIterationMethod","keys","MAP_KEY_ITERATE_KEY","_itr$next3","forEach","method","originMethod","Array","_len","arguments","length","args","_key","res","apply","_len2","_key2","_mutableInstrumentati","add","key","hadKey","has","trigger","delete","_delete","get","had","set","oldValue","rawValue","callback","thisArg","_this","v","k","mutableInstrumentations","createReactive","obj","isShallow","undefined","isReadonly","Proxy","receiver","Reflect","isArray","hasOwnProperty","readonly","ownKeys","newVal","oldVal","type","console","warn","concat","Number","deleteProperty","existionProxy","proxy","bucket","WeakMap","effectsToRun","iterateEffects","depsMap","effects","Set","effectFn","lengthEffects","iterateEffectKeys","options","scheduler","Text","Comment","Fragment","createElement","tag","document","setElementText","el","text","textContent","insert","parent","anchor","getElementById","insertBefore","createText","createTextNode","setText","nodeValue","createComment","shouldSetAsProps","tagName","patchProps","prevValue","nextValue","invoker","test","_vei","name","slice","toLowerCase","e","timeStamp","attached","fn","performance","now","addEventListener","removeEventListener","className","setAttribute","createRenderer","unmount","vnode","children","parentNode","removeChild","patchChildren","n1","n2","container","oldChildren","newChildren","i","newVNode","j","oldVNode","patch","c","patchElement","oldProps","props","newProps","mountElement","child","render","_vnode","hydrate","renderer","querySelector","setTimeout"],"mappings":"AACA,IAAIA,uhCCGMC,QAAQC,QAAO,ECJzB,0BAAMC,SAAWC,OAAOC,UAAUF,SAErBG,aAAe,SAACC,GAAK,OAAKJ,SAASK,KAAKD,CAAK,CAAC,EAG9CE,MAAQ,SAACC,GAAG,MAA2B,iBAAtBJ,aAAaI,CAAG,CAAoB,EAErDC,MAAQ,SAACD,GAAG,MAA2B,iBAAtBJ,aAAaI,CAAG,CAAoB,ECC5DE,YAAc,IAAIC,IAElBC,sBAAwB,GAkC7B,SAASC,kBAGO,SAAPC,EAAQN,GAAG,MAAoB,WAAfO,QAAOP,CAAG,EAAgBQ,SAASR,CAAG,EAAGA,CAAG,CAFlE,IAAMS,EAASC,KAAKC,IACdC,EAAMH,EAAOI,OAAOC,UAAS,EAGnC,OADAC,MAAMN,EAAQO,WAAW,EAClB,CACHC,KAAI,WACA,IAAAC,EAAwBN,EAAIK,KAAM,EAA1BpB,EAAKqB,EAALrB,MAAOsB,EAAID,EAAJC,KACf,MAAO,CACHtB,MAAQA,GAAQ,CAACS,EAAKT,EAAM,EAAE,EAAGS,EAAKT,EAAM,EAAE,GAC9CsB,KAAAA,EAER,EAEP,CAEA,SAASC,wBAEN,IAAMX,EAASC,KAAKC,IAEdC,EAAMH,EAAOY,SAInB,OAFAN,MAAMN,EAAQO,WAAW,EAEzBM,gBAAA,CACIL,KAAI,WACA,IAAAM,EAAwBX,EAAIK,KAAM,EAA1BpB,EAAK0B,EAAL1B,MAAOsB,EAAII,EAAJJ,KACf,MAAO,CAEHtB,MARyB,WAAfU,QAARP,EAQUH,CARQ,EAAgBW,SAASR,CAAG,EAAIA,EASpDmB,KAAAA,EAER,GACCN,OAAOC,SAAY,WAChB,OAAOJ,KACV,CAER,CAEA,SAASc,sBAEN,IAAMf,EAASC,KAAKC,IAEdC,EAAMH,EAAOgB,OAKnB,OAFAV,MAAMN,EAAQiB,mBAAmB,EAEjCJ,gBAAA,CACIL,KAAI,WACA,IAAAU,EAAwBf,EAAIK,KAAM,EAA1BpB,EAAK8B,EAAL9B,MAAOsB,EAAIQ,EAAJR,KACf,MAAO,CAEHtB,MATyB,WAAfU,QAARP,EASUH,CATQ,EAAgBW,SAASR,CAAG,EAAIA,EAUpDmB,KAAAA,EAER,GACCN,OAAOC,SAAY,WAChB,OAAOJ,KACV,CAER,CA9FA,CAAC,WAAY,UAAW,eAAekB,QAAQ,SAAAC,GAC5C,IAAMC,EAAeC,MAAMpC,UAAUkC,GACrCzB,sBAAsByB,GAAU,WAAkB,IAAA,IAAAG,EAAAC,UAAAC,OAANC,EAAIJ,IAAAA,MAAAC,CAAA,EAAAI,EAAA,EAAAA,EAAAJ,EAAAI,CAAA,GAAJD,EAAIC,GAAAH,UAAAG,GAE5C,IAAIC,EAAMP,EAAaQ,MAAM5B,KAAMyB,CAAI,EAMvC,OAHIE,EAFQ,CAAA,IAARA,GAAyB,CAAC,IAATA,EAKdA,EAHGP,EAAaQ,MAAM5B,KAAKC,IAAKwB,CAAI,EAKnD,CAAC,EAKC,CAAC,OAAQ,MAAO,QAAS,UAAW,UAAUP,QAAQ,SAAAC,GAEpD,IAAMC,EAAeC,MAAMpC,UAAUkC,GAErCzB,sBAAsByB,GAAU,WAG5B,IAAA,IAAAU,EAAAN,UAAAC,OAHwCC,EAAIJ,IAAAA,MAAAQ,CAAA,EAAAC,EAAA,EAAAA,EAAAD,EAAAC,CAAA,GAAJL,EAAIK,GAAAP,UAAAO,GAO5C,OAHUV,EAAaQ,MAAM5B,KAAMyB,CAAI,EAK9C,CAAC,EAsIGb,gBAnEyBmB,sBAAA,CAC1BC,IAAG,SAACC,GAEA,IAAMlC,EAASC,KAAKC,IAEdiC,EAASnC,EAAOoC,IAAIF,CAAG,EAEvBN,EAAM5B,EAAOiC,IAAIC,CAAG,EAM1B,OAJIC,GACAE,QAAQrC,EAAQkC,EAAK,KAAK,EAGvBN,CACV,EAAAU,OAAAC,SACML,GACH,IAAMlC,EAASC,KAAKC,IACdiC,EAASnC,EAAOoC,IAAIF,CAAG,EACvBN,EAAM5B,EAAa,OAACkC,CAAG,EAK7B,OAHIC,GACAE,QAAQrC,EAAQkC,EAAK,QAAQ,EAE1BN,CACV,EACDY,IAAG,SAACN,GAEA,IAAMlC,EAASC,KAAKC,IAEduC,EAAMzC,EAAOoC,IAAIF,CAAG,EAI1B,GAFA5B,MAAMN,EAAQkC,CAAG,EAEbO,EAEA,MAAsB,WAAf3C,QADD8B,EAAM5B,EAAOwC,IAAIN,CAAG,CACT,EAAgBnC,SAAS6B,CAAG,EAAIA,CAExD,EACDc,IAAGA,SAACR,EAAK9C,GACL,IAAMY,EAASC,KAAKC,IACduC,EAAMzC,EAAOoC,IAAIF,CAAG,EAEpBS,EAAW3C,EAAOwC,IAAIN,CAAG,EAEzBU,EAAWxD,EAAMc,KAAOd,EAE9BY,EAAO0C,IAAIR,EAAKU,CAAQ,EAEnBH,GAEOE,IAAavD,GAAUuD,GAAaA,GAAYvD,GAAUA,IAElEiD,QAAQrC,EAAQkC,EAAK,KAAK,EAH1BG,QAAQrC,EAAQkC,EAAK,KAAK,CAKjC,EACDf,QAAOA,SAAC0B,EAAUC,GAED,SAAPjD,EAAQN,GAAG,MAAoB,WAAfO,QAAOP,CAAG,EAAgBQ,SAASR,CAAG,EAAIA,CAAG,CAF5C,IAAAwD,EAAA9C,KAIjBD,EAASC,KAAKC,IAEpBI,MAAMN,EAAQO,WAAW,EAEzBP,EAAOmB,QAAQ,SAAC6B,EAAGC,GAEhBJ,EAASxD,KAAKyD,EAASjD,EAAKmD,CAAC,EAAGnD,EAAKoD,CAAC,EAAGF,CAAI,CAChD,CAAC,CACL,CAAC,EAEA3C,OAAOC,SAAWT,eAAe,EAAAiB,gBAAAmB,sBAAA,UACzBpC,eAAe,EAAAiB,gBAAAmB,sBAAA,SAChBrB,qBAAqB,EAAAE,gBAAAmB,sBAAA,OACvBjB,mBAAmB,EAxE5B,IAAMmC,wBAwEsBlB,sBAI7B,SAASmB,eAAeC,GAA4C,IAAvCC,EAAS,EAAA7B,UAAAC,QAAA6B,KAAAA,IAAA9B,UAAA,IAAAA,UAAA,GAAU+B,EAAU,EAAA/B,UAAAC,QAAA6B,KAAAA,IAAA9B,UAAA,IAAAA,UAAA,GACtD,OAAO,IAAIgC,MAAMJ,EAAK,CAElBZ,IAAK,SAAUxC,EAAQkC,EAAKuB,GAExB,GAAY,QAARvB,EACA,OAAOlC,EAEX,GAAY,SAARkC,EAGA,OADA5B,MAAMN,EAAQO,WAAW,EAClBmD,QAAQlB,IAAIxC,EAAQkC,EAAKlC,CAAM,EAG1C,GAAGV,MAAMU,CAAM,GAAKR,MAAMQ,CAAM,EAE5B,OAAOkD,wBAAwBhB,GAKnC,GAAIZ,MAAMqC,QAAQ3D,CAAM,GAAKL,sBAAsBiE,eAAe1B,CAAG,EACjE,OAAOwB,QAAQlB,IAAI7C,sBAAuBuC,EAAKuB,CAAQ,EAItDF,GAA6B,WAAfzD,QAAOoC,CAAG,GAEzB5B,MAAMN,EAAQkC,CAAG,EAGfN,EAAM8B,QAAQlB,IAAIxC,EAAQkC,EAAKuB,CAAQ,EAE7C,MAAIJ,CAAAA,GAGe,WAAfvD,QAAO8B,CAAG,GAAyB,OAARA,GAEpB2B,EAAaM,SAAgB9D,UAAP6B,CAAG,EAE7BA,CACV,EACDQ,IAAK,SAAUpC,EAAQkC,GAGnB,OADA5B,MAAMN,EAAQkC,CAAG,EACVwB,QAAQtB,IAAIpC,EAAQkC,CAAG,CACjC,EACD4B,QAAS,SAAU9D,GAGf,OADAM,MAAMN,EAAQsB,MAAMqC,QAAQ3D,CAAM,EAAI,SAAWO,WAAW,EACrDmD,QAAQI,QAAQ9D,CAAM,CAChC,EAED0C,IAAK,SAAU1C,EAAQkC,EAAK6B,EAAQN,GAEhC,IAKMO,EAGAC,EAMArC,EAdN,OAAI2B,GACAW,QAAQC,KAAI,MAAAC,OAAOlC,EAAW,OAAA,CAAA,EACvB,CAAA,IAGL8B,EAAShE,EAAOkC,GAGhB+B,EAAO3C,MAAMqC,QAAQ3D,CAAM,EAE/BqE,OAAOnC,CAAG,EAAIlC,EAAOyB,OAAS,MAAQ,MACtCxC,OAAOC,UAAU0E,eAAevE,KAAKW,EAAQkC,CAAG,EAAI,MAAQ,MAGxDN,EAAM8B,QAAQhB,IAAI1C,EAAQkC,EAAK6B,EAAQN,CAAQ,EAEjDzD,IAAWyD,EAASvD,KAEhB8D,IAAWD,GAAWC,GAAWA,GAAUD,GAAWA,GAEtD1B,QAAQrC,EAAQkC,EAAK+B,EAAMF,CAAM,EAIlCnC,EACV,EACD0C,eAAgB,SAAStE,EAAQkC,GAE7B,IAKMC,EAEAP,EAPN,OAAI2B,GACAW,QAAQC,KAAI,MAAAC,OAAOlC,EAAW,OAAA,CAAA,EACvB,CAAA,IAGLC,EAASlD,OAAOC,UAAU0E,eAAevE,KAAKW,EAAQkC,CAAG,GAEzDN,EAAM8B,QAAQY,eAAetE,EAAQkC,CAAG,IACnCC,GAEPE,QAAQrC,EAAQkC,EAAK,QAAQ,EAE1BN,EACX,CACJ,CAAC,CACL,CAEO,SAAS7B,SAASqD,GACrB,IAAMmB,EAAgB9E,YAAY+C,IAAIY,CAAG,EACzC,OAAImB,IAEEC,EAAQrB,eAAeC,CAAG,EAEhC3D,YAAYiD,IAAIU,EAAKoB,CAAK,EACnBA,EACX,CAOO,SAASX,SAAST,GACrB,OAAOD,eAAeC,EAAK,CAAA,EAAO,CAAA,CAAI,CAC1C,CCxSA,IAAMqB,OAAS,IAAIC,QAGNnE,YAAcH,OAAM,EAGpBa,oBAAsBb,OAAM,EAGlC,SAASE,MAAMN,EAAQkC,GAES,OAAOlC,EAAOkC,EAkBrD,CAKO,SAASG,QAAQrC,EAAQkC,EAAK+B,EAAMF,GACvC,IAIMY,EAsCIC,EA1CJC,EAAUJ,OAAOjC,IAAIxC,CAAM,EAC5B6E,IAECC,EAAUD,EAAQrC,IAAIN,CAAG,EACzByC,EAAe,IAAII,IAEzBD,GAAWA,EAAQ3D,QAAQ,SAAA6D,GAEnBA,IAAanG,cACb8F,EAAa1C,IAAI+C,CAAQ,CAEjC,CAAC,EAEY,QAATf,GAAkB3C,MAAMqC,QAAQ3D,CAAM,IAEhCiF,EAAgBJ,EAAQrC,IAAI,QAAQ,IAEzByC,EAAc9D,QAAQ,SAAA6D,GAC/BA,IAAanG,cACb8F,EAAa1C,IAAI+C,CAAQ,CAEjC,CAAC,EAGD1D,MAAMqC,QAAQ3D,CAAM,GAAa,WAARkC,GACzB2C,EAAQ1D,QAAQ,SAAC2D,EAAS5C,GACX6B,GAAP7B,GACA4C,EAAQ3D,QAAQ,SAAA6D,GACRA,IAAanG,cACb8F,EAAa1C,IAAI+C,CAAQ,CAEjC,CAAC,CAET,CAAC,GAGQ,QAATf,GACS,WAATA,GAEU,QAATA,GAAkB3E,MAAMU,CAAM,MAGzB4E,EAAiBC,EAAQrC,IAAIjC,WAAW,IAE5BqE,EAAezD,QAAQ,SAAA6D,GACjCA,IAAanG,cACb8F,EAAa1C,IAAI+C,CAAQ,CAEjC,CAAC,EAGKE,EAAoBL,EAAQrC,IAAIvB,mBAAmB,IAEpCiE,EAAkB/D,QAAQ,SAAA6D,GACvCA,IAAanG,cACb8F,EAAa1C,IAAI+C,CAAQ,CAEjC,CAAC,EAGLL,EAAaxD,QAAQ,SAAA6D,GACbA,EAASG,QAAQC,UACjBJ,EAASG,QAAQC,UAAUJ,CAAQ,EAEnCA,GAER,CAAC,EACL,CC1GO,IAAMK,KAAOjF,OAAM,EAGbkF,QAAUlF,OAAM,EAEhBmF,SAAWnF,OAAM,EAGvB,SAASoF,cAAcC,GAC1B,OAAOC,SAASF,cAAcC,CAAG,CACrC,CAEO,SAASE,eAAeC,EAAIC,GAC/BD,EAAGE,YAAcD,CACrB,CAEO,SAASE,OAAOH,EAAII,GAAuB,IAAfC,EAAM,EAAAzE,UAAAC,QAAA6B,KAAAA,IAAA9B,UAAA,GAAAA,UAAA,GAAG,MAEpCwE,EADe,SAAhBA,EAAO/B,KACGyB,SAASQ,eAAe,KAAK,EAE1CF,GAAOG,aAAaP,EAAIK,CAAM,CAClC,CAGO,SAASG,WAAWP,GACvB,OAAOH,SAASW,eAAeR,CAAI,CACvC,CAGO,SAASS,QAAQV,EAAIC,GACxBD,EAAGW,UAAYV,CACnB,CAGO,SAASW,cAAcX,GAC1B,OAAOH,SAASc,cAAcX,CAAI,CACtC,CAGA,SAASY,iBAAiBb,EAAI1D,EAAK9C,GAC/B,OAAY,SAAR8C,GAAiC,UAAf0D,EAAGc,UAClBxE,KAAO0D,CAClB,CAGO,SAASe,WAAWf,EAAI1D,EAAK0E,EAAWC,GAE3C,IAIQC,EAsCE7C,EA1CN,MAAM8C,KAAK7E,CAAG,GAIV4E,GAFWlB,EAAGoB,OAASpB,EAAGoB,KAAO,KAEd9E,GAEjB+E,EAAO/E,EAAIgF,MAAM,CAAC,EAAEC,YAAW,EACjCN,EACKC,EAqBDA,EAAQ1H,MAAQyH,IAnBhBC,EAAUlB,EAAGoB,KAAK9E,GAAO,SAACkF,GAElBA,EAAEC,UAAYP,EAAQQ,WAEtBhG,MAAMqC,QAAQmD,EAAQ1H,KAAK,EAC3B0H,EAAQ1H,MAAM+B,QAAQ,SAAAoG,GAAE,OAAIA,EAAGH,CAAC,EAAE,EAGlCN,EAAQ1H,MAAMgI,CAAC,KAIfhI,MAAQyH,EAEhBC,EAAQQ,SAAWE,YAAYC,MAE/B7B,EAAG8B,iBAAiBT,EAAMH,CAAO,GAK/BA,GAENlB,EAAG+B,oBAAoBV,EAAMH,CAAO,EAGxClB,EAAG8B,iBAAiBT,EAAMJ,CAAS,GAEtB,UAAR3E,EACL0D,EAAGgC,UAAYf,GAAa,GACrBJ,iBAAiBb,EAAI1D,CAAc,GAEpC+B,EAAInE,QAAU8F,EAAG1D,EAAI,EAGvB0D,EAAG1D,GADM,YAAT+B,GAAoC,KAAd4C,GAGZA,GAIdjB,EAAGiC,aAAa3F,EAAK2E,CAAS,CAEtC,CC9FA,SAASiB,eAAe3C,GAEpB,IACIK,EAOAL,EAPAK,cACAG,EAMAR,EANAQ,eACAI,EAKAZ,EALAY,OACAY,EAIAxB,EAJAwB,WACAP,EAGAjB,EAHAiB,WACAE,EAEAnB,EAFAmB,QACAE,EACArB,EADAqB,cAIJ,SAASuB,EAAQC,GAEb,IAKMhC,EALFgC,EAAM/D,OAASsB,SACfyC,EAAMC,SAAS9G,QAAa4G,CAAW,GAIrC/B,EAASgC,EAAMpC,GAAGsC,aAEZlC,EAAOmC,YAAYH,EAAMpC,EAAE,CAC3C,CA6BA,SAASwC,EAAcC,EAAIC,EAAIC,GAE3B,GAA2B,UAAvB,OAAOD,EAAGL,SAEN3G,MAAMqC,QAAQ0E,EAAGJ,QAAQ,GACzBI,EAAGJ,SAAS9G,QAAe4G,CAAW,EAG1CpC,EAAe4C,EAAWD,EAAGL,QAAQ,OACjC,GAAI3G,MAAMqC,QAAQ2E,EAAGL,QAAQ,EAEjC,GAAI3G,MAAMqC,QAAQ0E,EAAGJ,QAAQ,EAMzB,IAJA,IAAMO,EAAcH,EAAGJ,SACjBQ,EAAcH,EAAGL,SAGdS,EAAI,EAAGA,EAAID,EAAYhH,OAAQiH,CAAC,GAGrC,IAFA,IAAMC,EAAWF,EAAYC,GAEpBE,EAAI,EAAGA,EAAIJ,EAAY/G,OAAQmH,CAAC,GAAI,CACzC,IAAMC,EAAWL,EAAYI,GAE7B,GAAID,EAASzG,MAAQ2G,EAAS3G,IAAK,CAC/B4G,EAAMD,EAAUF,EAAUJ,CAAS,EACnC,KACJ,CACJ,MA2BJ5C,EAAe4C,EAAW,EAAE,EAC5BD,EAAGL,SAAS9G,QAAQ,SAAA4H,GAAC,OAAID,EAAM,KAAMC,EAAGR,CAAS,EAAE,OAInDjH,MAAMqC,QAAQ0E,EAAGJ,QAAQ,EACzBI,EAAGJ,SAAS9G,QAAa4G,CAAW,EACN,UAAvB,OAAOM,EAAGJ,UAEjBtC,EAAe4C,EAAW,EAAE,CAGxC,CAwBA,SAASO,EAAMT,EAAIC,EAAIC,GAEfF,GAAMA,EAAGpE,OAASqE,EAAGrE,OAErB8D,EAAQM,CAAE,EACVA,EAAK,MAGT,IA4BczC,EA5BN3B,EAASqE,EAATrE,KAER,GAAoB,UAAhB,OAAOA,EAEP,GAAKoE,EAEE,CAEHW,IAhCG9G,EAKAA,EAVOmG,EAqCGA,EArCCC,EAqCGA,EApCnB1C,EAAK0C,EAAG1C,GAAKyC,EAAGzC,GAChBqD,EAAWZ,EAAGa,MACdC,EAAWb,EAAGY,MAEpB,IAAWhH,KAAOiH,EACVA,EAASjH,KAAS+G,EAAS/G,IAC3ByE,EAAWf,EAAI1D,EAAK+G,EAAS/G,GAAMiH,EAASjH,EAAI,EAGxD,IAAWA,KAAO+G,EACR/G,KAAOiH,GACTxC,EAAWf,EAAI1D,EAAK+G,EAAS/G,GAAM,IAAI,EAI/CkG,EAAcC,EAAIC,EAAI1C,CAAE,CAsBpB,KALS,CACLwD,IAjIUpB,EAiIGM,EAjIIC,EAiIAA,EA/HnB3C,EAAKoC,EAAMpC,GAAKJ,EAAcwC,EAAM/D,IAAI,EAY9C,GAV8B,UAA1B,OAAO+D,EAAMC,SAEbtC,EAAeC,EAAIoC,EAAMC,QAAQ,EAC3B3G,MAAMqC,QAAQqE,EAAMC,QAAQ,GAElCD,EAAMC,SAAS9G,QAAQ,SAAAkI,GACnBP,EAAM,KAAMO,EAAOzD,CAAE,CACzB,CAAC,EAGDoC,EAAMkB,MAEN,IAAK,IAAMhH,KAAO8F,EAAMkB,MAEpBvC,EAAWf,EAAI1D,EAAK,KAAM8F,EAAMkB,MAAMhH,EAAI,EAIlD6D,EAAOH,EAAI2C,CAAS,CA4GhB,MAIOtE,IAASoB,KAEXgD,GAOKzC,EAAK0C,EAAG1C,GAAKyC,EAAGzC,GAClB0C,EAAGL,WAAaI,EAAGJ,UACnB3B,EAAQV,EAAI0C,EAAGL,QAAQ,IAPrBrC,EAAK0C,EAAG1C,GAAKQ,EAAWkC,EAAGL,QAAQ,EAEzClC,EAAOH,EAAI2C,CAAS,GAQjBtE,IAASqB,QAEX+C,GAOKzC,EAAK0C,EAAG1C,GAAKyC,EAAGzC,GAClB0C,EAAGL,WAAaI,EAAGJ,UACnB3B,EAAQV,EAAI0C,EAAGL,QAAQ,IAPrBrC,EAAK0C,EAAG1C,GAAKY,EAAc8B,EAAGL,QAAQ,EAE5ClC,EAAOH,EAAI2C,CAAS,GAQjBtE,IAASsB,SACX8C,EAKDD,EAAcC,EAAIC,EAAIC,CAAS,EAH/BD,EAAGL,SAAS9G,QAAQ,SAAA4H,GAAC,OAAID,EAAM,KAAMC,EAAGR,CAAS,EAAE,EAKjDzI,QAAOmE,CAAI,CAIzB,CAoBA,MAAO,CACHqF,OAnBJ,SAAgBtB,EAAOO,GACfP,EAEAc,EAAMP,EAAUgB,OAAQvB,EAAOO,CAAS,EAEpCA,EAAUgB,QAEVxB,EAAQQ,EAAUgB,MAAM,EAIhChB,EAAUgB,OAASvB,CACvB,EAQIwB,QANJ,SAAiBxB,EAAOO,KAQ5B,CClNA,IAAMkB,SAAW3B,eAAe,CAC5BtC,cAAAA,cAAeG,eAAAA,eAAgBI,OAAAA,OAAQY,WAAAA,WAAYP,WAAAA,WAAYE,QAAAA,QAASE,cAAAA,aAC5E,CAAC,EA8KKqC,SAAW,CACb5E,KAAM,MACNgE,SAAU,CACN,CAAEhE,KAAM,IAAKgE,SAAU,IAAK/F,IAAK,CAAE,EACnC,CAAE+B,KAAM,IAAKgE,SAAU,IAAK/F,IAAK,CAAE,EACnC,CAAE+B,KAAM,IAAKgE,SAAU,QAAS/F,IAAK,GAE7C,EAEMyG,SAAW,CACb1E,KAAM,MACNgE,SAAU,CACN,CAAEhE,KAAM,IAAKgE,SAAU,QAAS/F,IAAK,CAAE,EACvC,CAAE+B,KAAM,IAAKgE,SAAU,IAAK/F,IAAK,CAAE,EACnC,CAAE+B,KAAM,IAAKgE,SAAU,IAAK/F,IAAK,GAEzC,EAGCuH,SAASH,OAAOT,SAAUnD,SAASgE,cAAc,MAAM,CAAC,EACxDC,WAAW,WAERF,SAASH,OAAOX,SAAUjD,SAASgE,cAAc,MAAM,CAAC,CAC3D,EAAG,GAAI"}